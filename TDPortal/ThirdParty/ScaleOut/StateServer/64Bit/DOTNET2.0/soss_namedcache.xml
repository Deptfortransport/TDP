<?xml version="1.0"?>
<doc>
    <assembly>
        <name>soss_namedcache</name>
    </assembly>
    <members>
        <member name="T:Soss.Client.SossObjDescriptor">
            <summary>
            Contains information neccessary to insert an object into a NamedCache via a bulk <see cref="M:Soss.Client.NamedCache.Add(System.Collections.IDictionary)"/> operation.
            </summary>
        </member>
        <member name="M:Soss.Client.SossObjDescriptor.#ctor(System.Object,Soss.Client.CreatePolicy,Soss.Client.ObjectMetadata)">
            <summary>
            Creates a SossObjDescriptor class with the metadata and CreatePolicy information needed to 
            insert an object via a bulk <see cref="M:Soss.Client.NamedCache.Add(System.Collections.IDictionary)"/> operation.
            </summary>
            <param name="obj">Object to insert into the NamedCache.</param>
            <param name="policy">Policy information for the object being inserted.</param>
            <param name="metadata">Metadata related to object being inserted.</param>
        </member>
        <member name="P:Soss.Client.SossObjDescriptor.Policy">
            <summary>
            Policy information for the object being inserted.
            </summary>
        </member>
        <member name="P:Soss.Client.SossObjDescriptor.Metadata">
            <summary>
            Metadata related to object being inserted.
            </summary>
        </member>
        <member name="P:Soss.Client.SossObjDescriptor.Obj">
            <summary>
            The object to insert into the NamedCache.
            </summary>
        </member>
        <member name="P:Soss.Client.SossObjDescriptor.InsertException">
            <summary>
            Exception encountered by a bulk <see cref="M:Soss.Client.NamedCache.Add(System.Collections.IDictionary)"/> operation, or null if the object was
            added to the NamedCache successfully. This property can be checked after a <see cref="M:Soss.Client.NamedCache.Add(System.Collections.IDictionary)"/> call
            to see if the corresponding object was inserted.
            </summary>
        </member>
        <member name="T:Soss.Client.Serializer">
            <summary>
            A delegate to a method that can serialize an object into a <see cref="T:System.IO.Stream"/>.
            </summary>
            <param name="stream">the <see cref="T:System.IO.Stream"/> into which <paramref name="obj"/> is to be serialized</param>
            <param name="obj">the object to serialize</param>
        </member>
        <member name="T:Soss.Client.Deserializer">
            <summary>
            A delegate to a method that can deserialize an object previously serialized with <see cref="T:Soss.Client.Serializer"/> from the supplied <paramref name="stream"/>.
            </summary>
            <param name="stream">the <see cref="T:System.IO.Stream"/> from which the serialized object can be read</param>
            <returns>the deserialized object</returns>
        </member>
        <member name="T:Soss.Client.NamedCache">
            <summary>
            Provides access to a named collection of objects that can be shared globally across multiple clients.
            </summary>
            <remarks>
            <para>
            The NamedCache class provides a collection-based API suitable for caching a group of objects within a single, named cache. The <see cref="M:Soss.Client.CacheFactory.GetCache(System.String)"/> method must be used to access a NamedCache instance.
            </para><para>
            Objects within a named cache are identified using IDs of type <see cref="T:Soss.Client.CachedObjectId"/>. Object identifiers can be constructed from a variety of types such as strings, guids, and byte arrays, and they are constrained to identify objects within a single named cache.
            </para><para>
            A number of advanced caching features are available through the NamedCache class. When inserting an object into a cache, an expiration time for the object can be specified, as well the expiration behavior (sliding vs. absolute). Dependencies between objects can also be defined, allowing a dependent object to be automatically removed when one of its parent objects is updated or removed.
            </para><para>
            ScaleOut StateServer allows an object to be locked across every server in the farm. This per-object lock can be used to ensure that other clients do not alter the object while the lock is being held. All clients' code should take care to acquire a lock prior to performing an operation that could disrupt (or be disrupted by) other clients. The NamedCache will automatically perform <see cref="P:Soss.Client.NamedCache.MaxLockAttempts">retries</see> when trying to acquire a lock.
            </para><para>
            The NamedCache class offers two properties to simplify usage of the advanced features of a named cache. The <see cref="P:Soss.Client.NamedCache.UseLocking"/> property controls the default locking behavior for the <see cref="P:Soss.Client.NamedCache.Item(System.String)"/> accessor and <see cref="M:Soss.Client.NamedCache.Get(System.String)"/> method, and the <see cref="P:Soss.Client.NamedCache.DefaultCreatePolicy"/> property controls the default policies that are used when adding items to the cache through <see cref="M:Soss.Client.NamedCache.Add(System.String,System.Object)"/> and <see cref="P:Soss.Client.NamedCache.Item(System.String)"/>. Finer grained control over locking and caching policies can be achieved by using the more advanced <see cref="M:Soss.Client.NamedCache.Insert(System.String,System.Object,Soss.Client.CreatePolicy,System.Boolean,System.Boolean)"/>, <see cref="M:Soss.Client.NamedCache.Update(System.String,System.Object,System.Boolean)"/>, and <see cref="M:Soss.Client.NamedCache.Retrieve(System.String,System.Boolean)"/> methods.
            </para><para>
            Every object in the cache can have up to 8 index values associated with it. Users are responsible for setting and managing these index values using the <see cref="M:Soss.Client.NamedCache.SetMetadata(System.String,Soss.Client.ObjectMetadata,System.Boolean)"/> method, and, once set, these index values can be queried for by using the <see cref="M:Soss.Client.NamedCache.Query(Soss.Client.IFilter)"/> method. The result of a Query operation is a collection of object identifiers that can be used to access the matching objects in the cache.
            </para><para>
            Under low-memory situations, ScaleOut StateServer can be configured to remove the least frequently used objects from the cache in order to free up room for newer ones. By default, all objects in the cache are subject to this reclamation, but this behavior can be overridden by setting the object's priority when the object is first added to the cache (see the <see cref="T:Soss.Client.CreatePolicy"/> class used by <see cref="M:Soss.Client.NamedCache.Insert(System.String,System.Object,Soss.Client.CreatePolicy,System.Boolean,System.Boolean)"/> and <see cref="P:Soss.Client.NamedCache.DefaultCreatePolicy"/>). See the "Configuration Parameters" topic in the SOSS help file for details on how to enable object reclamation in the server with the <c>lru_threshold</c> parameter.
            </para>
            </remarks>
            <example>
            <code>
            using System;
            using System.IO;
            using System.Net;
            using System.Text;
            using Soss.Client;
            
            class Program
            {
                static void Main(string[] args)
                {
                    // Looking up a stock quote via a web service is expensive,
                    // so we check the cache to see if it has a fresh value:
                    NamedCache cache = CacheFactory.GetCache("LatestQuotes");
                    StockQuote msftQuote = cache["MSFT"] as StockQuote;
            
                    if (msftQuote == null)
                    {
                        // Cache miss. Hit the web service for the stock price:
                        msftQuote = downloadQuote("MSFT");
            
                        // Set up the cache to hold on to quotes for 2 minutes:
                        CreatePolicy cachePolicy = new CreatePolicy();
                        cachePolicy.TimeoutMinutes = 2;
                        cachePolicy.IsAbsoluteTimeout = true;
                        cache.DefaultCreatePolicy = cachePolicy;
            
                        // Objects added to the cache must be serializable:
                        cache["MSFT"] = msftQuote;
                    }
            
                    Console.WriteLine("MSFT: " + msftQuote.LastPrice);
            	}
            
                static StockQuote downloadQuote(string symbol)
                {
                    const string url = "http://download.finance.yahoo.com/d/quotes.csv?s={0}&amp;f=l1d1t1v";
            
                    HttpWebRequest request = (HttpWebRequest)WebRequest.Create(string.Format(url, symbol));
                    HttpWebResponse response = (HttpWebResponse)request.GetResponse();
                    Stream receiveStream = response.GetResponseStream();
                    StreamReader readStream = new StreamReader(receiveStream, Encoding.UTF8);
            
                    // Stock data is returned as a comma-separated string. Split into array:
                    string[] rawData = readStream.ReadToEnd().Split(new char[] { ',' });
                    response.Close();
                    readStream.Close();
            
                    // Populate the StockQuote Object:
                    StockQuote quote = new StockQuote();
                    quote.LastPrice = decimal.Parse(rawData[0]);
                    quote.LastTradeTime = DateTime.Parse(rawData[1].Replace("\"", "") + " " +
                                                         rawData[2].Replace("\"", ""));
                    quote.Volume = int.Parse(rawData[3]);
                    return quote;
                }
            }
            
            [Serializable]
            class StockQuote
            {
                public decimal LastPrice = -1;
                public int Volume = -1;
                public DateTime LastTradeTime = DateTime.MinValue;
            }
            </code>
            </example>
            <seealso cref="T:Soss.Client.CacheFactory"/>
            <seealso cref="T:Soss.Client.CachedObjectId"/>
            <seealso cref="P:Soss.Client.NamedCache.Item(Soss.Client.CachedObjectId)"/>
            <seealso cref="M:Soss.Client.NamedCache.Add(Soss.Client.CachedObjectId,System.Object)"/>
            <seealso cref="P:Soss.Client.NamedCache.UseLocking"/>
            <seealso cref="P:Soss.Client.NamedCache.DefaultCreatePolicy"/>
            <seealso cref="M:Soss.Client.NamedCache.Insert(Soss.Client.CachedObjectId,System.Object,Soss.Client.CreatePolicy,System.Boolean,System.Boolean)"/>
            <seealso cref="M:Soss.Client.NamedCache.Update(Soss.Client.CachedObjectId,System.Object,System.Boolean)"/>
            <seealso cref="M:Soss.Client.NamedCache.Retrieve(Soss.Client.CachedObjectId,System.Boolean)"/>
            <seealso cref="P:Soss.Client.NamedCache.MaxLockAttempts"/>
            <seealso cref="P:Soss.Client.NamedCache.LockRetryInterval"/>
            <threadsafety static="true" instance="true"/>
        </member>
        <member name="F:Soss.Client.NamedCache._allowClientCaching">
            <summary>
            Enables or disables client-side caching.
            If it is enabled objects are saved in client-side cache in addition to server cache.
            </summary>
        </member>
        <member name="F:Soss.Client.NamedCache._useLocking">
            <summary>
            Member used by the indexer that determines whether the get operation performs a lock on the object on the server and whether
            the setter perfroms an unlock.
            </summary>
        </member>
        <member name="F:Soss.Client.NamedCache._defaultCreatePolicy">
            <summary>
            CreatePolicy object used as default parameter for Add, Get, [] .
            </summary>
        </member>
        <member name="F:Soss.Client.NamedCache._maxLockAttempts">
            <summary>
            Number of times to retry acquiring a lock.
            </summary>
        </member>
        <member name="F:Soss.Client.NamedCache._sleepInterval">
            <summary>
            Milliseconds to wait between attempts to acquire a lock.
            </summary>
        </member>
        <member name="F:Soss.Client.NamedCache._maxReadThroughPendingAttempts">
            <summary>
            Number of times to retry a read if a database read-through operation is pending.
            </summary>
        </member>
        <member name="F:Soss.Client.NamedCache._readPendingRetryInterval">
            <summary>
            Milliseconds to wait between attempts to read an object if a database read-through operation is pending.
            </summary>
        </member>
        <member name="F:Soss.Client.NamedCache._serializationCallbacks">
            <summary>
            Delegates to user-supplied serialize/deserialize methods. We use delegates rather
            than an interface so that we can marshal them to remote hosts when running PMI
            using the existing method delegate marshalling mechanism. We hold them in a separate
            object to ensure that we always have a consistent pair.
            </summary>
        </member>
        <member name="F:Soss.Client.NamedCache._backingStoreAdapter">
            <summary>
            Class that can be used by the NamedCache to automatically interact with
            an external data source (a database, typically) for read-through, write-through,
            refresh-ahead, and write-behind operations. Set via SetBackingStoreAdapter().
            </summary>
        </member>
        <member name="F:Soss.Client.NamedCache._enableReadThrough">
            <summary>
            Determines whether synchonous read-through/write-through operations are performed
            using an instance of IBackingStore.
            </summary>
        </member>
        <member name="F:Soss.Client.NamedCache._lockedDAs">
            <summary>
            Hashtable to tracks locked objects on a per-thread basis. 
            </summary>
        </member>
        <member name="F:Soss.Client.NamedCache.eventRegistrationsByAppId">
            <summary>
            A Hashtable to hold <see cref="T:Soss.Client.EventRegistration"/> instances by appId.
            </summary>
        </member>
        <member name="M:Soss.Client.NamedCache.#ctor(System.String)">
            <summary>
            Creates a named cache with the given name and registers the cache with the <see cref="T:Soss.Client.CacheFactory"/>.
            </summary>
            <remarks>
            <see cref="T:Soss.Client.NamedCache"/> instances should normally be created via the <see cref="T:Soss.Client.CacheFactory"/>
            methods. This signature is available for implementing NamedCache subclasses.
            <para>
            If a <see cref="T:Soss.Client.NamedCache"/> has already been created for the application namespace name
            <paramref name="cacheName"/> then registration with the <see cref="T:Soss.Client.CacheFactory"/> will fail
            and this constructor will throw an <see cref="T:System.InvalidOperationException"/>.
            </para>
            </remarks>
            <param name="cacheName">The name of the cache</param>
            <exception cref="T:System.ArgumentNullException">if <paramref name="cacheName"/> is null</exception>
            <exception cref="T:System.InvalidOperationException">
            	if a <see cref="T:Soss.Client.NamedCache"/> instance is already registered with the <see cref="T:Soss.Client.CacheFactory"/> for the given name.
            </exception>
        </member>
        <member name="M:Soss.Client.NamedCache.#ctor(System.UInt32)">
            <summary>
            Creates a named cache. This constructor is used by the <see cref="T:Soss.Client.CacheFactory"/> and should not be invoked by client code.
            </summary>
            <param name="id">application id</param>
        </member>
        <member name="M:Soss.Client.NamedCache.Insert(Soss.Client.CachedObjectId,System.Object,Soss.Client.CreatePolicy,System.Boolean,System.Boolean)">
            <summary>
            Inserts a serializable object to a named cache. If an object with the same ID already exists in the cache then it can optionally be updated.
            </summary>
            <param name="id">Object identifier.</param>
            <param name="obj">Serializable object to store in the cache. The argument cannot be null.</param>
            <param name="createPolicy"><see cref="T:Soss.Client.CreatePolicy"/> instance containing extended cache policy information for the object.</param>
            <param name="updateIfExists">Determines behavior if the object already exists in the cache. If <c>true</c>, the object will be updated; if false, an <see cref="T:Soss.Client.ObjectExistsException"/> will be thrown if the object already exists.</param>
            <param name="lockAfterInsert">If <c>true</c>, StateServer will atomically create and lock the object so that additional updates may be performed under a StateServer lock. If <c>false</c>, StateServer will create the object but leave it unlocked, allowing other clients to lock the object.</param>
            <remarks>
            <para>
            Passing <c>null</c> into the <paramref name="obj"/> parameter is not allowed; use <see cref="M:Soss.Client.NamedCache.Remove(Soss.Client.CachedObjectId)"/> to delete an object from the cache.
            </para><para>
            If <paramref name="updateIfExists"/> is <c>true</c>, and a cache object is being updated instead of inserted, then the policy settings in the <paramref name="createPolicy"/> parameter will not be applied to the updated object; instead, the object will continue use the <see cref="T:Soss.Client.CreatePolicy"/> policies that were in effect when the object was originally added to the cache. The object must be explicitly removed and re-inserted into the cache for new <see cref="T:Soss.Client.CreatePolicy"/> policies to take effect.
            </para><para>
            Objects added to the cache with a <see cref="P:Soss.Client.CreatePolicy.PreemptionPriority"/> of Normal will only be removed under low memory situations if LRU functionality is enabled in StateServer. Edit the soss_params.txt file in the StateServer installation directory to enable this feature: the lru_threshold parameter should be set to a percentage of the max_memory parameter. Eligible objects will be deleted using a least recently used algorithm once memory usage has passed the threshold.
            </para>
            </remarks>
            <exception cref="T:Soss.Client.ObjectLockedException">Thrown if the object is already in the cache and is locked by another client.</exception>
            <exception cref="T:Soss.Client.ObjectExistsException">Thrown if the object exists and the updateIfExists paramater is <c>false</c>.</exception>
            <exception cref="T:Soss.Client.StateServerException">Thrown if ScaleOut StateServer is unavailable or has experienced an internal error.</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="obj"/> or <paramref name="createPolicy"/> is null.</exception>
            <example>
            <code>
            using System;
            using Soss.Client;
            
            class Program
            {
                static void Main(string[] args)
                {
                    NamedCache cache = CacheFactory.GetCache("Sample Cache");
                    
                    // There are 3 ways to add an object to a cache: an indexer, the Add() method, or the Insert() method.
            
                    // Approach 1: Indexer - can be used to add or update objects in the cache using DefaultCreatePolicy rules:
                    cache["key1"] = "This is the first item in the cache.";
            
                    // Approach 2: Add() method - functionally identical to using an indexer to add or update objects in the cache:
                    cache.Add("key2", "This is the second item in the cache.");
            
                    // Approach 3: Insert() method - allows objects to be added to the cache with specific CreatePolicy rules and locking options:
                    CreatePolicy policy = new CreatePolicy();
                    policy.TimeoutMinutes = 10;
                    policy.IsAbsoluteTimeout = true;
                    policy.Dependencies = new object[] { "key1", "key2" };
                    
                    cache.Insert("key3", "This is the third item in the cache", policy, false, false);
            
                    // Remove the first object and confirm the third is removed because of its dependency relationship:
                    cache["key1"] = null;
                    System.Diagnostics.Debug.Assert(cache["key3"] == null);
                }
            }
            </code>
            </example>
        </member>
        <member name="M:Soss.Client.NamedCache.Insert(System.Byte[],System.Object,Soss.Client.CreatePolicy,System.Boolean,System.Boolean)">
            <summary>
            Inserts a serializable object to a named cache. If an object with the same ID already exists in the cache then it can optionally be updated.
            </summary>
            <param name="id">Object identifier (must be either 16 or 32 bytes in length).</param>
            <param name="obj">Serializable object to store in the cache. The argument cannot be null.</param>
            <param name="createPolicy"><see cref="T:Soss.Client.CreatePolicy"/> instance containing extended cache policy information for the object.</param>
            <param name="updateIfExists">Determines behavior if the object already exists in the cache. If <c>true</c>, the object will be updated; if false, an <see cref="T:Soss.Client.ObjectExistsException"/> will be thrown if the object already exists.</param>
            <param name="lockAfterInsert">If <c>true</c>, StateServer will atomically create and lock the object so that additional updates may be performed under a StateServer lock. If <c>false</c>, StateServer will create the object but leave it unlocked, allowing other clients to lock the object.</param>
            <remarks>
            <para>
            Passing <c>null</c> into the <paramref name="obj"/> parameter is not allowed; use <see cref="M:Soss.Client.NamedCache.Remove(System.Byte[])"/> to delete an object from the cache.
            </para><para>
            If <paramref name="updateIfExists"/> is <c>true</c>, and a cache object is being updated instead of inserted, then the policy settings in the <paramref name="createPolicy"/> parameter will not be applied to the updated object; instead, the object will continue use the <see cref="T:Soss.Client.CreatePolicy"/> policies that were in effect when the object was originally added to the cache. The object must be explicitly removed and re-inserted into the cache for new <see cref="T:Soss.Client.CreatePolicy"/> policies to take effect.
            </para><para>
            Objects added to the cache with a <see cref="P:Soss.Client.CreatePolicy.PreemptionPriority"/> of Normal will only be removed under low memory situations if LRU functionality is enabled in StateServer. Edit the soss_params.txt file in the StateServer installation directory to enable this feature: the lru_threshold parameter should be set to a percentage of the max_memory parameter. Eligible objects will be deleted using a least recently used algorithm once memory usage has passed the threshold.
            </para>
            </remarks>
            <exception cref="T:Soss.Client.ObjectLockedException">Thrown if the object is already in the cache and is locked by another client.</exception>
            <exception cref="T:Soss.Client.ObjectExistsException">Thrown if the object exists and the updateIfExists paramater is <c>false</c>.</exception>
            <exception cref="T:Soss.Client.StateServerException">Thrown if ScaleOut StateServer is unavailable or has experienced an internal error.</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="obj"/> or <paramref name="createPolicy"/> is null.</exception>
            <example>
            <code>
            using System;
            using Soss.Client;
            
            class Program
            {
                static void Main(string[] args)
                {
                    NamedCache cache = CacheFactory.GetCache("Sample Cache");
                    
                    // There are 3 ways to add an object to a cache: an indexer, the Add() method, or the Insert() method.
            
                    // Approach 1: Indexer - can be used to add or update objects in the cache using DefaultCreatePolicy rules:
                    cache["key1"] = "This is the first item in the cache.";
            
                    // Approach 2: Add() method - functionally identical to using an indexer to add or update objects in the cache:
                    cache.Add("key2", "This is the second item in the cache.");
            
                    // Approach 3: Insert() method - allows objects to be added to the cache with specific CreatePolicy rules and locking options:
                    CreatePolicy policy = new CreatePolicy();
                    policy.TimeoutMinutes = 10;
                    policy.IsAbsoluteTimeout = true;
                    policy.Dependencies = new object[] { "key1", "key2" };
                    
                    cache.Insert("key3", "This is the third item in the cache", policy, false, false);
            
                    // Remove the first object and confirm the third is removed because of its dependency relationship:
                    cache["key1"] = null;
                    System.Diagnostics.Debug.Assert(cache["key3"] == null);
                }
            }
            </code>
            </example>
        </member>
        <member name="M:Soss.Client.NamedCache.Insert(System.String,System.Object,Soss.Client.CreatePolicy,System.Boolean,System.Boolean)">
            <summary>
            Inserts a serializable object to a named cache. If an object with the same ID already exists in the cache then it can optionally be updated.
            </summary>
            <param name="id">Object identifier.</param>
            <param name="obj">Serializable object to store in the cache. The argument cannot be null.</param>
            <param name="createPolicy"><see cref="T:Soss.Client.CreatePolicy"/> instance containing extended cache policy information for the object.</param>
            <param name="updateIfExists">Determines behavior if the object already exists in the cache. If <c>true</c>, the object will be updated; if false, an <see cref="T:Soss.Client.ObjectExistsException"/> will be thrown if the object already exists.</param>
            <param name="lockAfterInsert">If <c>true</c>, StateServer will atomically create and lock the object so that additional updates may be performed under a StateServer lock. If <c>false</c>, StateServer will create the object but leave it unlocked, allowing other clients to lock the object.</param>
            <remarks>
            <para>
            Passing <c>null</c> into the <paramref name="obj"/> parameter is not allowed; use <see cref="M:Soss.Client.NamedCache.Remove(System.String)"/> to delete an object from the cache.
            </para><para>
            If <paramref name="updateIfExists"/> is <c>true</c>, and a cache object is being updated instead of inserted, then the policy settings in the <paramref name="createPolicy"/> parameter will not be applied to the updated object; instead, the object will continue use the <see cref="T:Soss.Client.CreatePolicy"/> policies that were in effect when the object was originally added to the cache. The object must be explicitly removed and re-inserted into the cache for new <see cref="T:Soss.Client.CreatePolicy"/> policies to take effect.
            </para><para>
            Object identifiers passed into this property are hashed into keys using (by default)
            the <see cref="T:System.Security.Cryptography.SHA256Managed"/> hash algorithm prior to being sent to 
            ScaleOut StateServer. The choice of HashAlgorithm is configurable. See 
            <see cref="M:Soss.Client.ApplicationNamespace.CreateKey(System.String)"/> for details.
            </para><para>
            Objects added to the cache with a <see cref="P:Soss.Client.CreatePolicy.PreemptionPriority"/> of Normal will only be removed under low memory situations if LRU functionality is enabled in StateServer. Edit the soss_params.txt file in the StateServer installation directory to enable this feature: the lru_threshold parameter should be set to a percentage of the max_memory parameter. Eligible objects will be deleted using a least recently used algorithm once memory usage has passed the threshold.
            </para>
            </remarks>
            <exception cref="T:Soss.Client.ObjectLockedException">Thrown if the object is already in the cache and is locked by another client.</exception>
            <exception cref="T:Soss.Client.ObjectExistsException">Thrown if the object exists and the updateIfExists paramater is <c>false</c>.</exception>
            <exception cref="T:Soss.Client.StateServerException">Thrown if ScaleOut StateServer is unavailable or has experienced an internal error.</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="obj"/> or <paramref name="createPolicy"/> is null.</exception>
            <example>
            <code>
            using System;
            using Soss.Client;
            
            class Program
            {
                static void Main(string[] args)
                {
                    NamedCache cache = CacheFactory.GetCache("Sample Cache");
                    
                    // There are 3 ways to add an object to a cache: an indexer, the Add() method, or the Insert() method.
            
                    // Approach 1: Indexer - can be used to add or update objects in the cache using DefaultCreatePolicy rules:
                    cache["key1"] = "This is the first item in the cache.";
            
                    // Approach 2: Add() method - functionally identical to using an indexer to add or update objects in the cache:
                    cache.Add("key2", "This is the second item in the cache.");
            
                    // Approach 3: Insert() method - allows objects to be added to the cache with specific CreatePolicy rules and locking options:
                    CreatePolicy policy = new CreatePolicy();
                    policy.TimeoutMinutes = 10;
                    policy.IsAbsoluteTimeout = true;
                    policy.Dependencies = new object[] { "key1", "key2" };
                    
                    cache.Insert("key3", "This is the third item in the cache", policy, false, false);
            
                    // Remove the first object and confirm the third is removed because of its dependency relationship:
                    cache["key1"] = null;
                    System.Diagnostics.Debug.Assert(cache["key3"] == null);
                }
            }
            </code>
            </example>
        </member>
        <member name="M:Soss.Client.NamedCache.Insert(System.Guid,System.Object,Soss.Client.CreatePolicy,System.Boolean,System.Boolean)">
            <summary>
            Inserts a serializable object to a named cache. If an object with the same ID already exists in the cache then it can optionally be updated.
            </summary>
            <param name="id">Object identifier.</param>
            <param name="obj">Serializable object to store in the cache. The argument cannot be null.</param>
            <param name="createPolicy"><see cref="T:Soss.Client.CreatePolicy"/> instance containing extended cache policy information for the object.</param>
            <param name="updateIfExists">Determines behavior if the object already exists in the cache. If <c>true</c>, the object will be updated; if false, an <see cref="T:Soss.Client.ObjectExistsException"/> will be thrown if the object already exists.</param>
            <param name="lockAfterInsert">If <c>true</c>, StateServer will atomically create and lock the object so that additional updates may be performed under a StateServer lock. If <c>false</c>, StateServer will create the object but leave it unlocked, allowing other clients to lock the object.</param>
            <remarks>
            <para>
            Passing <c>null</c> into the <paramref name="obj"/> parameter is not allowed; use <see cref="M:Soss.Client.NamedCache.Remove(Soss.Client.CachedObjectId)"/> to delete an object from the cache.
            </para><para>
            If <paramref name="updateIfExists"/> is <c>true</c>, and a cache object is being updated instead of inserted, then the policy settings in the <paramref name="createPolicy"/> parameter will not be applied to the updated object; instead, the object will continue use the <see cref="T:Soss.Client.CreatePolicy"/> policies that were in effect when the object was originally added to the cache. The object must be explicitly removed and re-inserted into the cache for new <see cref="T:Soss.Client.CreatePolicy"/> policies to take effect.
            </para><para>
            Objects added to the cache with a <see cref="P:Soss.Client.CreatePolicy.PreemptionPriority"/> of Normal will only be removed under low memory situations if LRU functionality is enabled in StateServer. Edit the soss_params.txt file in the StateServer installation directory to enable this feature: the lru_threshold parameter should be set to a percentage of the max_memory parameter. Eligible objects will be deleted using a least recently used algorithm once memory usage has passed the threshold.
            </para>
            </remarks>
            <exception cref="T:Soss.Client.ObjectLockedException">Thrown if the object is already in the cache and is locked by another client.</exception>
            <exception cref="T:Soss.Client.ObjectExistsException">Thrown if the object exists and the updateIfExists paramater is <c>false</c>.</exception>
            <exception cref="T:Soss.Client.StateServerException">Thrown if ScaleOut StateServer is unavailable or has experienced an internal error.</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="obj"/> or <paramref name="createPolicy"/> is null.</exception>
            <example>
            <code>
            using System;
            using Soss.Client;
            
            class Program
            {
                static void Main(string[] args)
                {
                    NamedCache cache = CacheFactory.GetCache("Sample Cache");
                    
                    // There are 3 ways to add an object to a cache: an indexer, the Add() method, or the Insert() method.
            
                    // Approach 1: Indexer - can be used to add or update objects in the cache using DefaultCreatePolicy rules:
                    cache["key1"] = "This is the first item in the cache.";
            
                    // Approach 2: Add() method - functionally identical to using an indexer to add or update objects in the cache:
                    cache.Add("key2", "This is the second item in the cache.");
            
                    // Approach 3: Insert() method - allows objects to be added to the cache with specific CreatePolicy rules and locking options:
                    CreatePolicy policy = new CreatePolicy();
                    policy.TimeoutMinutes = 10;
                    policy.IsAbsoluteTimeout = true;
                    policy.Dependencies = new object[] { "key1", "key2" };
                    
                    cache.Insert("key3", "This is the third item in the cache", policy, false, false);
            
                    // Remove the first object and confirm the third is removed because of its dependency relationship:
                    cache["key1"] = null;
                    System.Diagnostics.Debug.Assert(cache["key3"] == null);
                }
            }
            </code>
            </example>
        </member>
        <member name="M:Soss.Client.NamedCache.Put(Soss.Client.CachedObjectId,System.Object,Soss.Client.CreatePolicy,Soss.Client.ObjectMetadata)">
            <summary>
            Performs a DA.Put operation. Doesn't currently support locking calls, so hiding this from users
            for the time being until the API design settles down.
            </summary>
            <exclude/>
        </member>
        <member name="M:Soss.Client.NamedCache.Put(System.Byte[],System.Object,Soss.Client.CreatePolicy,Soss.Client.ObjectMetadata)">
            <exclude/>
        </member>
        <member name="M:Soss.Client.NamedCache.Put(System.Guid,System.Object,Soss.Client.CreatePolicy,Soss.Client.ObjectMetadata)">
            <exclude/>
        </member>
        <member name="M:Soss.Client.NamedCache.Put(System.String,System.Object,Soss.Client.CreatePolicy,Soss.Client.ObjectMetadata)">
            <exclude/>
        </member>
        <member name="M:Soss.Client.NamedCache.Add(Soss.Client.CachedObjectId,System.Object)">
            <summary>
            Adds an item to the cache using default parameters. If the object already exists in the cache then it will be updated.
            </summary>
            <remarks>
            <para>
            The <see cref="M:Soss.Client.NamedCache.Add(Soss.Client.CachedObjectId,System.Object)"/> method will use the cache policy settings from the <see cref="P:Soss.Client.NamedCache.DefaultCreatePolicy"/> property when adding an object to the cache. If an object with the specified <paramref name="id"/> already exists in the cache then it will be updated. The <see cref="M:Soss.Client.NamedCache.Insert(Soss.Client.CachedObjectId,System.Object,Soss.Client.CreatePolicy,System.Boolean,System.Boolean)"/> method can be used instead of the <see cref="M:Soss.Client.NamedCache.Add(Soss.Client.CachedObjectId,System.Object)"/> method if this automatic update behavior is not desired.
            </para><para>
            If an existing cached object is being updated instead of added then the current <see cref="P:Soss.Client.NamedCache.DefaultCreatePolicy"/> settings will not be applied to the updated object; the object will continue to use the <see cref="T:Soss.Client.CreatePolicy"/> policies that were in effect when the object was originally added to the cache. The object must be explicitly removed and re-added to the cache for new <see cref="T:Soss.Client.CreatePolicy"/> policies to take effect.
            </para><para>
            Use the <see cref="M:Soss.Client.NamedCache.Insert(Soss.Client.CachedObjectId,System.Object,Soss.Client.CreatePolicy,System.Boolean,System.Boolean)"/> method to add items with specific <see cref="T:Soss.Client.CreatePolicy"/> parameters instead of the default ones.
            </para>
            </remarks>
            <param name="id">Object identifier.</param>
            <param name="o">Serializable object to store in the cache. If the argument is null then an object with the same <paramref name="id"/> will be removed from the cache.</param>
            <exception cref="T:Soss.Client.ObjectLockedException">Thrown if the object is already in the cache and is locked by another client.</exception>
            <exception cref="T:Soss.Client.StateServerException">Thrown if ScaleOut StateServer is unavailable or has experienced an internal error.</exception>
        </member>
        <member name="M:Soss.Client.NamedCache.Add(System.Byte[],System.Object)">
            <summary>
            Adds an item to the cache using default parameters. If the object already exists in the cache then it will be updated.
            </summary>
            <remarks>
            <para>
            The <see cref="M:Soss.Client.NamedCache.Add(System.Byte[],System.Object)"/> method will use the cache policy settings from the <see cref="P:Soss.Client.NamedCache.DefaultCreatePolicy"/> property when adding an object to the cache. If an object with the specified <paramref name="id"/> already exists in the cache then it will be updated. The <see cref="M:Soss.Client.NamedCache.Insert(System.Byte[],System.Object,Soss.Client.CreatePolicy,System.Boolean,System.Boolean)"/> method can be used instead of the <see cref="M:Soss.Client.NamedCache.Add(System.Byte[],System.Object)"/> method if this automatic update behavior is not desired.
            </para><para>
            If an existing cached object is being updated instead of added then the current <see cref="P:Soss.Client.NamedCache.DefaultCreatePolicy"/> settings will not be applied to the updated object; the object will continue to use the <see cref="T:Soss.Client.CreatePolicy"/> policies that were in effect when the object was originally added to the cache. The object must be explicitly removed and re-added to the cache for new <see cref="T:Soss.Client.CreatePolicy"/> policies to take effect.
            </para><para>
            Use the <see cref="M:Soss.Client.NamedCache.Insert(System.Byte[],System.Object,Soss.Client.CreatePolicy,System.Boolean,System.Boolean)"/> method to add items with specific <see cref="T:Soss.Client.CreatePolicy"/> parameters instead of the default ones.
            </para>
            </remarks>
            <param name="id">Object identifier (must be either 16 or 32 bytes in length).</param>
            <param name="o">Serializable object to store in the cache. If the argument is null then an object with the same <paramref name="id"/> will be removed from the cache.</param>
            <exception cref="T:Soss.Client.ObjectLockedException">Thrown if the object is already in the cache and is locked by another client.</exception>
            <exception cref="T:Soss.Client.StateServerException">Thrown if ScaleOut StateServer is unavailable or has experienced an internal error.</exception>
        </member>
        <member name="M:Soss.Client.NamedCache.Add(System.String,System.Object)">
            <summary>
            Adds an item to the cache using default parameters. If the object already exists in the cache then it will be updated.
            </summary>
            <remarks>
            <para>
            The <see cref="M:Soss.Client.NamedCache.Add(System.String,System.Object)"/> method will use the cache policy settings from the <see cref="P:Soss.Client.NamedCache.DefaultCreatePolicy"/> property when adding an object to the cache. If an object with the specified <paramref name="id"/> already exists in the cache then it will be updated. The <see cref="M:Soss.Client.NamedCache.Insert(System.String,System.Object,Soss.Client.CreatePolicy,System.Boolean,System.Boolean)"/> method can be used instead of the <see cref="M:Soss.Client.NamedCache.Add(System.String,System.Object)"/> method if this automatic update behavior is not desired.
            </para><para>
            If an existing cached object is being updated instead of added then the current <see cref="P:Soss.Client.NamedCache.DefaultCreatePolicy"/> settings will not be applied to the updated object; the object will continue to use the <see cref="T:Soss.Client.CreatePolicy"/> policies that were in effect when the object was originally added to the cache. The object must be explicitly removed and re-added to the cache for new <see cref="T:Soss.Client.CreatePolicy"/> policies to take effect.
            </para><para>
            Use the <see cref="M:Soss.Client.NamedCache.Insert(System.String,System.Object,Soss.Client.CreatePolicy,System.Boolean,System.Boolean)"/> method to add items with specific <see cref="T:Soss.Client.CreatePolicy"/> parameters instead of the default ones.
            </para>
            </remarks>
            <param name="id">Object identifier.</param>
            <param name="o">Serializable object to store in the cache. If the argument is null then an object with the same <paramref name="id"/> will be removed from the cache.</param>
            <exception cref="T:Soss.Client.ObjectLockedException">Thrown if the object is already in the cache and is locked by another client.</exception>
            <exception cref="T:Soss.Client.StateServerException">Thrown if ScaleOut StateServer is unavailable or has experienced an internal error.</exception>
        </member>
        <member name="M:Soss.Client.NamedCache.Add(System.Guid,System.Object)">
            <summary>
            Adds an item to the cache using default parameters. If the object already exists in the cache then it will be updated.
            </summary>
            <remarks>
            <para>
            The <see cref="M:Soss.Client.NamedCache.Add(System.Guid,System.Object)"/> method will use the cache policy settings from the <see cref="P:Soss.Client.NamedCache.DefaultCreatePolicy"/> property when adding an object to the cache. If an object with the specified <paramref name="id"/> already exists in the cache then it will be updated. The <see cref="M:Soss.Client.NamedCache.Insert(System.String,System.Object,Soss.Client.CreatePolicy,System.Boolean,System.Boolean)"/> method can be used instead of the <see cref="M:Soss.Client.NamedCache.Add(System.String,System.Object)"/> method if this automatic update behavior is not desired.
            </para><para>
            If an existing cached object is being updated instead of added then the current <see cref="P:Soss.Client.NamedCache.DefaultCreatePolicy"/> settings will not be applied to the updated object; the object will continue to use the <see cref="T:Soss.Client.CreatePolicy"/> policies that were in effect when the object was originally added to the cache. The object must be explicitly removed and re-added to the cache for new <see cref="T:Soss.Client.CreatePolicy"/> policies to take effect.
            </para><para>
            Use the <see cref="M:Soss.Client.NamedCache.Insert(System.Guid,System.Object,Soss.Client.CreatePolicy,System.Boolean,System.Boolean)"/> method to add items with specific <see cref="T:Soss.Client.CreatePolicy"/> parameters instead of the default ones.
            </para>
            </remarks>
            <param name="id">Object identifier.</param>
            <param name="o">Serializable object to store in the cache. If the argument is null then an object with the same <paramref name="id"/> will be removed from the cache.</param>
            <exception cref="T:Soss.Client.ObjectLockedException">Thrown if the object is already in the cache and is locked by another client.</exception>
            <exception cref="T:Soss.Client.StateServerException">Thrown if ScaleOut StateServer is unavailable or has experienced an internal error.</exception>
        </member>
        <member name="M:Soss.Client.NamedCache.Add(System.Collections.IDictionary)">
            <summary>
            Efficiently adds a large collection of objects to the cache.
            </summary>
            <param name="objects">An IDictionary containing objects to store in the cache with keys of type <see cref="T:Soss.Client.CachedObjectId"/>, string, or byte[], and with values that are either data objects to be stored or <see cref="T:Soss.Client.SossObjDescriptor"/> objects.</param>
            <remarks>
            <para>
            The <see cref="M:Soss.Client.NamedCache.Add(System.Collections.IDictionary)"/> method takes an IDictionary of objects and adds them to the named cache in the SOSS distributed cache. Keys to objects in the dictionary must be of type string, Guid, byte[], or CachedObjectId. If the SOSS cache already contains objects corresponding to keys in the dictionary then those objects will be updated in the SOSS cache. If the dictionary contains a null value for a key then the corresponding item in the SOSS cache will be removed.
            </para><para>
            The <see cref="M:Soss.Client.NamedCache.Add(System.Collections.IDictionary)"/> method leverages the distributed, multithreaded architecture of ScaleOut StateServer to reduce the total time needed to add a large number of objects. This method also can improve performance several times if a small number of large objects need to be added to the SOSS cache.
            </para><para>
            By default, the <see cref="M:Soss.Client.NamedCache.Add(System.Collections.IDictionary)"/> method will use the default cache policy from the <see cref="P:Soss.Client.NamedCache.DefaultCreatePolicy"/> property when adding an object to the cache, and no metadata for the object will be set. Alternatively, each object in the IDictionary optionally can specify its own cache policy and associated metadata. To assign cache policy and metadata on an object-by-object basis, the associated value within the dictionary should contain a  <see cref="T:Soss.Client.SossObjDescriptor"/> objects instead of the data object to be stored in the SOSS cache. In this case, the SossObjDescriptor's <see cref="T:Soss.Client.SossObjDescriptor"/>'s <see cref="P:Soss.Client.SossObjDescriptor.Policy"/> and <see cref="P:Soss.Client.SossObjDescriptor.Metadata"/> properties will be used to assign the object's policy and metadata, and Add will use this descriptor to obtain a reference to the data object. The dictionary may contain a mix of simple data objects and SossObjDescriptor objects.
            </para>
            </remarks>
            <exception cref="T:Soss.Client.BulkAddException">Thrown if errors are encountered during the add operation. If the <paramref name="objects"/> parameter is a collection of <see cref="T:Soss.Client.SossObjDescriptor"/> elements, those elements will contain specific exceptions in their <see cref="P:Soss.Client.SossObjDescriptor.InsertException"/> property (or null, if the associated object was added to the cache successfully) after the add operation is complete.</exception>
            <example>
            <code>
            using System;
            using System.Collections.Generic;
            using Soss.Client;
            
            class Program
            {
                const int OBJECT_COUNT = 10000;
            
                static void Main(string[] args)
                {
                    InsertObjects();
                    InsertObjectsEx();
                }
            
                // Add objects using the NamedCache's DefaultCreatePolicy and no metadata
                static void InsertObjects()
                {
                    // set up the collection of objects to be added to the cache:
                    Dictionary&lt;string, string&gt; objColl = new Dictionary&lt;string, string&gt;();
                    for (int i = 0; i &lt; OBJECT_COUNT; i++)
                    {
                        string cacheKey = "key" + i.ToString();
                        string cachedObj = "This is an object in the cache: " + i.ToString();
                        objColl.Add(cacheKey, cachedObj);
                    }
            
                    NamedCache cache = CacheFactory.GetCache("cache1");
                    cache.Add(objColl);
                }
            
                // Add objects objects with metadata and specific policy settings:
                static void InsertObjectsEx()
                {
                    // put SossObjDescriptor instances in the collection to specify metadata and cache policy:
                    Dictionary&lt;string, SossObjDescriptor&gt; objColl = new Dictionary&lt;string, SossObjDescriptor&gt;();
                    for (int i = 0; i &lt; OBJECT_COUNT; i++)
                    {
                        string cacheKey = "key" + i.ToString();
                        string cachedObj = "This is an object in the cache: " + i.ToString();
                        
                        // set up metadata to associate with the cached object:
                        ObjectMetadata meta = new ObjectMetadata();
                        meta.IndexCollection[0] = new IndexValue("index value" + i.ToString());
            
                        // set up a cache policy with a timeout for the object:
                        CreatePolicy policy = new CreatePolicy(TimeSpan.FromMinutes(i));
            
                        objColl.Add(cacheKey, new SossObjDescriptor(cachedObj, policy, meta));
                    }
            
                    NamedCache cache = CacheFactory.GetCache("cache2");
                    cache.Add(objColl);
                }
            }
            </code>
            </example>
        </member>
        <member name="M:Soss.Client.NamedCache.Update(Soss.Client.CachedObjectId,System.Object,System.Boolean)">
            <summary>
            Updates an object in the named cache.
            </summary>
            <param name="id">Object identifier.</param>
            <param name="obj">The new value for the object in the shared cache. The argument must be serializable, and it cannot be null.</param>
            <param name="unlockAfterUpdate">
            <para>If the <see cref="T:Soss.Client.NamedCache"/> instance is not holding a lock for the specified object, this parameter is ignored.</para>
            <para>If <paramref name="unlockAfterUpdate"/> is <c>true</c> and the <see cref="T:Soss.Client.NamedCache"/> is holding a lock for the object then the lock will be released when the update operation completes.</para>
            <para>If <paramref name="unlockAfterUpdate"/> is <c>false</c> and the <see cref="T:Soss.Client.NamedCache"/> is holding a lock for the object then the lock will continue to be held when the update operation completes.</para>
            </param>
            <remarks>
            <para>
            The <see cref="M:Soss.Client.NamedCache.Update(Soss.Client.CachedObjectId,System.Object,System.Boolean)"/> method updates an object in the named cache and allows for fine-grained control over locking of the object. Unlike the <see cref="P:Soss.Client.NamedCache.Item(Soss.Client.CachedObjectId)"/> accessor, the <see cref="M:Soss.Client.NamedCache.Update(Soss.Client.CachedObjectId,System.Object,System.Boolean)"/> method does not honor the <see cref="P:Soss.Client.NamedCache.UseLocking"/> property. The <see cref="M:Soss.Client.NamedCache.AcquireLock(Soss.Client.CachedObjectId)"/> or <see cref="M:Soss.Client.NamedCache.Retrieve(Soss.Client.CachedObjectId,System.Boolean)"/> methods must be called prior to <see cref="M:Soss.Client.NamedCache.Update(Soss.Client.CachedObjectId,System.Object,System.Boolean)"/> if the object needs to be locked.
            </para><para>
            Care should be taken when performing unlocked updates on objects. An unlocked update will not block for locks held by another clients, so other clients may have the object data changed underneath them despite the locks they hold.
            </para>
            </remarks>
            <exception cref="T:Soss.Client.ObjectNotFoundException">Thrown if the object to update does not exist in the cache.</exception>
            <exception cref="T:Soss.Client.StateServerException">Thrown if ScaleOut StateServer is unavailable or has experienced an internal error.</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="o"/> is null.</exception>
        </member>
        <member name="M:Soss.Client.NamedCache.Update(System.Byte[],System.Object,System.Boolean)">
            <summary>
            Updates an object in the named cache.
            </summary>
            <param name="id">Object identifier. The argument must be an array of either 16 or 32 bytes.</param>
            <param name="obj">The new value for the object in the shared cache. The argument must be serializable, and it cannot be null.</param>
            <param name="unlockAfterUpdate">
            <para>If the <see cref="T:Soss.Client.NamedCache"/> instance is not holding a lock for the specified object, this parameter is ignored.</para>
            <para>If <paramref name="unlockAfterUpdate"/> is <c>true</c> and the <see cref="T:Soss.Client.NamedCache"/> is holding a lock for the object then the lock will be released when the update operation completes.</para>
            <para>If <paramref name="unlockAfterUpdate"/> is <c>false</c> and the <see cref="T:Soss.Client.NamedCache"/> is holding a lock for the object then the lock will continue to be held when the update operation completes.</para>
            </param>
            <remarks>
            <para>
            The <see cref="M:Soss.Client.NamedCache.Update(System.Byte[],System.Object,System.Boolean)"/> method updates an object in the named cache and allows for fine-grained control over locking of the object. Unlike the <see cref="P:Soss.Client.NamedCache.Item(System.Byte[])"/> accessor, the <see cref="M:Soss.Client.NamedCache.Update(System.Byte[],System.Object,System.Boolean)"/> method does not honor the <see cref="P:Soss.Client.NamedCache.UseLocking"/> property. The <see cref="M:Soss.Client.NamedCache.AcquireLock(System.Byte[])"/> or <see cref="M:Soss.Client.NamedCache.Retrieve(System.Byte[],System.Boolean)"/> method must be called prior to <see cref="M:Soss.Client.NamedCache.Update(System.Byte[],System.Object,System.Boolean)"/> if the object needs to be locked.
            </para><para>
            Care should be taken when performing unlocked updates on objects. An unlocked update will not block for locks held by another clients, so other clients may have the object data changed underneath them despite the locks they hold.
            </para>
            </remarks>
            <exception cref="T:Soss.Client.ObjectNotFoundException">Thrown if the object to update does not exist in the cache.</exception>
            <exception cref="T:Soss.Client.StateServerException">Thrown if ScaleOut StateServer is unavailable or has experienced an internal error.</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="o"/> is null.</exception>
        </member>
        <member name="M:Soss.Client.NamedCache.Update(System.String,System.Object,System.Boolean)">
            <summary>
            Updates an object in the named cache.
            </summary>
            <param name="id">Object identifier.</param>
            <param name="obj">The new value for the object in the shared cache. The argument must be serializable, and it cannot be null.</param>
            <param name="unlockAfterUpdate">
            <para>If the <see cref="T:Soss.Client.NamedCache"/> instance is not holding a lock for the specified object, this parameter is ignored.</para>
            <para>If <paramref name="unlockAfterUpdate"/> is <c>true</c> and the <see cref="T:Soss.Client.NamedCache"/> is holding a lock for the object then the lock will be released when the update operation completes.</para>
            <para>If <paramref name="unlockAfterUpdate"/> is <c>false</c> and the <see cref="T:Soss.Client.NamedCache"/> is holding a lock for the object then the lock will continue to be held when the update operation completes.</para>
            </param>
            <remarks>
            <para>
            The <see cref="M:Soss.Client.NamedCache.Update(System.String,System.Object,System.Boolean)"/> method updates an object in the named cache and allows for fine-grained control over locking of the object. Unlike the <see cref="P:Soss.Client.NamedCache.Item(System.String)"/> accessor, the <see cref="M:Soss.Client.NamedCache.Update(System.String,System.Object,System.Boolean)"/> method does not honor the <see cref="P:Soss.Client.NamedCache.UseLocking"/> property. The <see cref="M:Soss.Client.NamedCache.AcquireLock(System.String)"/> or <see cref="M:Soss.Client.NamedCache.Retrieve(System.String,System.Boolean)"/> method must be called prior to <see cref="M:Soss.Client.NamedCache.Update(System.String,System.Object,System.Boolean)"/> if the object needs to be locked.
            </para><para>
            Care should be taken when performing unlocked updates on objects. An unlocked update will not block for locks held by another clients, so other clients may have the object data changed underneath them despite the locks they hold.
            </para>
            </remarks>
            <exception cref="T:Soss.Client.ObjectNotFoundException">Thrown if the object to update does not exist in the cache.</exception>
            <exception cref="T:Soss.Client.StateServerException">Thrown if ScaleOut StateServer is unavailable or has experienced an internal error.</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="o"/> is null.</exception>
        </member>
        <member name="M:Soss.Client.NamedCache.Update(System.Guid,System.Object,System.Boolean)">
            <summary>
            Updates an object in the named cache.
            </summary>
            <param name="id">Object identifier.</param>
            <param name="obj">The new value for the object in the shared cache. The argument must be serializable, and it cannot be null.</param>
            <param name="unlockAfterUpdate">
            <para>If the <see cref="T:Soss.Client.NamedCache"/> instance is not holding a lock for the specified object, this parameter is ignored.</para>
            <para>If <paramref name="unlockAfterUpdate"/> is <c>true</c> and the <see cref="T:Soss.Client.NamedCache"/> is holding a lock for the object then the lock will be released when the update operation completes.</para>
            <para>If <paramref name="unlockAfterUpdate"/> is <c>false</c> and the <see cref="T:Soss.Client.NamedCache"/> is holding a lock for the object then the lock will continue to be held when the update operation completes.</para>
            </param>
            <remarks>
            <para>
            The <see cref="M:Soss.Client.NamedCache.Update(System.Guid,System.Object,System.Boolean)"/> method updates an object in the named cache and allows for fine-grained control over locking of the object. Unlike the <see cref="P:Soss.Client.NamedCache.Item(System.Guid)"/> accessor, the <see cref="M:Soss.Client.NamedCache.Update(System.Guid,System.Object,System.Boolean)"/> method does not honor the <see cref="P:Soss.Client.NamedCache.UseLocking"/> property. The <see cref="M:Soss.Client.NamedCache.AcquireLock(System.Guid)"/> or <see cref="M:Soss.Client.NamedCache.Retrieve(System.Guid,System.Boolean)"/> method must be called prior to <see cref="M:Soss.Client.NamedCache.Update(System.Guid,System.Object,System.Boolean)"/> if the object needs to be locked.
            </para><para>
            Care should be taken when performing unlocked updates on objects. An unlocked update will not block for locks held by another clients, so other clients may have the object data changed underneath them despite the locks they hold.
            </para>
            </remarks>
            <exception cref="T:Soss.Client.ObjectNotFoundException">Thrown if the object to update does not exist in the cache.</exception>
            <exception cref="T:Soss.Client.StateServerException">Thrown if ScaleOut StateServer is unavailable or has experienced an internal error.</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="o"/> is null.</exception>
        </member>
        <member name="M:Soss.Client.NamedCache.SetMetadata(Soss.Client.CachedObjectId,Soss.Client.ObjectMetadata,System.Boolean)">
            <summary>
            Creates and updates settable index values for a cached object and optionally unlocks the object.
            </summary>
            <param name="id">Object identifier.</param>
            <param name="metadata">The new metadata for the object, containing a collection of index values.</param>
            <param name="unlock">If the object was previously locked with the current SossCahce and <paramref name="unlock"/> is <c>true</c> then the object will be unlocked after the operation completes.</param>
            <remarks>
            <para>
            The <see cref="M:Soss.Client.NamedCache.SetMetadata(Soss.Client.CachedObjectId,Soss.Client.ObjectMetadata,System.Boolean)"/> method does not honor the <see cref="P:Soss.Client.NamedCache.UseLocking"/> property. Use the <see cref="M:Soss.Client.NamedCache.AcquireLock(Soss.Client.CachedObjectId)"/> or <see cref="M:Soss.Client.NamedCache.Retrieve(Soss.Client.CachedObjectId,System.Boolean)"/> methods prior to calling <see cref="M:Soss.Client.NamedCache.SetMetadata(Soss.Client.CachedObjectId,Soss.Client.ObjectMetadata,System.Boolean)"/> if the object needs to be locked.
            </para><para>
            Care should be taken when performing unlocked metadata changes on objects. An unlocked <see cref="M:Soss.Client.NamedCache.SetMetadata(Soss.Client.CachedObjectId,Soss.Client.ObjectMetadata,System.Boolean)"/> operation will not block for locks held by another clients, so other clients may have the object metadata changed underneath them despite the locks they hold.
            </para>
            </remarks>
            <see cref="M:Soss.Client.NamedCache.GetMetadata(Soss.Client.CachedObjectId,System.Boolean)"/>
            <exception cref="T:Soss.Client.ObjectNotFoundException">Thrown if the object to update does not exist in the shared cache.</exception>
            <exception cref="T:Soss.Client.ObjectLockedException">Thrown if the lock on the cached object exceeded the 90 second timeout period and another client acquired the lock.</exception>
            <exception cref="T:Soss.Client.StateServerException">Thrown if ScaleOut StateServer is unavailable or has experienced an internal error.</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="metadata"/> is null.</exception>
        </member>
        <member name="M:Soss.Client.NamedCache.SetMetadata(System.Byte[],Soss.Client.ObjectMetadata,System.Boolean)">
            <summary>
            Creates and updates settable index values for a cached object and optionally unlocks the object.
            </summary>
            <param name="id">Object identifier (must be either 16 or 32 bytes in length).</param>
            <param name="metadata">The new metadata for the object, containing a collection of index values.</param>
            <param name="unlock">If the object was previously locked with the current SossCahce and <paramref name="unlock"/> is <c>true</c> then the object will be unlocked after the operation completes.</param>
            <remarks>
            <para>
            The <see cref="M:Soss.Client.NamedCache.SetMetadata(System.Byte[],Soss.Client.ObjectMetadata,System.Boolean)"/> method does not honor the <see cref="P:Soss.Client.NamedCache.UseLocking"/> property. Use the <see cref="M:Soss.Client.NamedCache.AcquireLock(System.Byte[])"/> or <see cref="M:Soss.Client.NamedCache.Retrieve(System.Byte[],System.Boolean)"/> methods prior to calling <see cref="M:Soss.Client.NamedCache.SetMetadata(System.Byte[],Soss.Client.ObjectMetadata,System.Boolean)"/> if the object needs to be locked.
            </para><para>
            Care should be taken when performing unlocked metadata changes on objects. An unlocked <see cref="M:Soss.Client.NamedCache.SetMetadata(System.Byte[],Soss.Client.ObjectMetadata,System.Boolean)"/> operation will not block for locks held by another clients, so other clients may have the object metadata changed underneath them despite the locks they hold.
            </para>
            </remarks>
            <see cref="M:Soss.Client.NamedCache.GetMetadata(Soss.Client.CachedObjectId,System.Boolean)"/>
            <exception cref="T:Soss.Client.ObjectNotFoundException">Thrown if the object to update does not exist in the shared cache.</exception>
            <exception cref="T:Soss.Client.ObjectLockedException">Thrown if the lock on the cached object exceeded the 90 second timeout period and another client acquired the lock.</exception>
            <exception cref="T:Soss.Client.StateServerException">Thrown if ScaleOut StateServer is unavailable or has experienced an internal error.</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="metadata"/> is null.</exception>
        </member>
        <member name="M:Soss.Client.NamedCache.SetMetadata(System.String,Soss.Client.ObjectMetadata,System.Boolean)">
            <summary>
            Creates and updates settable index values for a cached object and optionally unlocks the object.
            </summary>
            <param name="id">Object identifier.</param>
            <param name="metadata">The new metadata for the object, containing a collection of index values.</param>
            <param name="unlock">If the object was previously locked with the current SossCahce and <paramref name="unlock"/> is <c>true</c> then the object will be unlocked after the operation completes.</param>
            <remarks>
            <para>
            The <see cref="M:Soss.Client.NamedCache.SetMetadata(System.String,Soss.Client.ObjectMetadata,System.Boolean)"/> method does not honor the <see cref="P:Soss.Client.NamedCache.UseLocking"/> property. Use the <see cref="M:Soss.Client.NamedCache.AcquireLock(System.String)"/> or <see cref="M:Soss.Client.NamedCache.Retrieve(System.String,System.Boolean)"/> methods prior to calling <see cref="M:Soss.Client.NamedCache.SetMetadata(System.String,Soss.Client.ObjectMetadata,System.Boolean)"/> if the object needs to be locked.
            </para><para>
            Care should be taken when performing unlocked metadata changes on objects. An unlocked <see cref="M:Soss.Client.NamedCache.SetMetadata(Soss.Client.CachedObjectId,Soss.Client.ObjectMetadata,System.Boolean)"/> operation will not block for locks held by another clients, so other clients may have the object metadata changed underneath them despite the locks they hold.
            </para>
            </remarks>
            <see cref="M:Soss.Client.NamedCache.GetMetadata(Soss.Client.CachedObjectId,System.Boolean)"/>
            <exception cref="T:Soss.Client.ObjectNotFoundException">Thrown if the object to update does not exist in the shared cache.</exception>
            <exception cref="T:Soss.Client.ObjectLockedException">Thrown if the lock on the cached object exceeded the 90 second timeout period and another client acquired the lock.</exception>
            <exception cref="T:Soss.Client.StateServerException">Thrown if ScaleOut StateServer is unavailable or has experienced an internal error.</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="metadata"/> is null.</exception>
        </member>
        <member name="M:Soss.Client.NamedCache.SetMetadata(System.Guid,Soss.Client.ObjectMetadata,System.Boolean)">
            <summary>
            Creates and updates settable index values for a cached object and optionally unlocks the object.
            </summary>
            <param name="id">Object identifier.</param>
            <param name="metadata">The new metadata for the object, containing a collection of index values.</param>
            <param name="unlock">If the object was previously locked with the current SossCahce and <paramref name="unlock"/> is <c>true</c> then the object will be unlocked after the operation completes.</param>
            <remarks>
            <para>
            The <see cref="M:Soss.Client.NamedCache.SetMetadata(System.Guid,Soss.Client.ObjectMetadata,System.Boolean)"/> method does not honor the <see cref="P:Soss.Client.NamedCache.UseLocking"/> property. Use the <see cref="M:Soss.Client.NamedCache.AcquireLock(System.Guid)"/> or <see cref="M:Soss.Client.NamedCache.Retrieve(System.Guid,System.Boolean)"/> methods prior to calling <see cref="M:Soss.Client.NamedCache.SetMetadata(System.Guid,Soss.Client.ObjectMetadata,System.Boolean)"/> if the object needs to be locked.
            </para><para>
            Care should be taken when performing unlocked metadata changes on objects. An unlocked <see cref="M:Soss.Client.NamedCache.SetMetadata(Soss.Client.CachedObjectId,Soss.Client.ObjectMetadata,System.Boolean)"/> operation will not block for locks held by another clients, so other clients may have the object metadata changed underneath them despite the locks they hold.
            </para>
            </remarks>
            <see cref="M:Soss.Client.NamedCache.GetMetadata(Soss.Client.CachedObjectId,System.Boolean)"/>
            <exception cref="T:Soss.Client.ObjectNotFoundException">Thrown if the object to update does not exist in the shared cache.</exception>
            <exception cref="T:Soss.Client.ObjectLockedException">Thrown if the lock on the cached object exceeded the 90 second timeout period and another client acquired the lock.</exception>
            <exception cref="T:Soss.Client.StateServerException">Thrown if ScaleOut StateServer is unavailable or has experienced an internal error.</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="metadata"/> is null.</exception>
        </member>
        <member name="M:Soss.Client.NamedCache.GetMetadata(Soss.Client.CachedObjectId,System.Boolean)">
            <summary>
            Gets the index values for an object in the named cache.
            </summary>
            <param name="id">Object identifier.</param>
            <param name="acquireLock">If true, indicates that the method should attempt to acquire a lock on the object when reading it from the server.</param>
            <returns>If the object identified by <paramref name="id"/> is found in the cache, the object's <see cref="T:Soss.Client.ExtendedObjectMetadata"/> is returned. If the object is not found in the cache, <c>null</c> is returned.</returns>
            <remarks>
            This method optionally locks the object in SOSS to prevent other clients from updating 
            or removing the object. The <see cref="P:Soss.Client.NamedCache.UseLocking"/> property is not taken into consideration by this method. If the <paramref name="acquireLock"/> parameter is true, this 
            call will block until the lock is acquired or the <see cref="P:Soss.Client.NamedCache.MaxLockAttempts"/> limit 
            has been met. The lock affects the entire object, not just its metadata, and can be released through a call to <see cref="M:Soss.Client.NamedCache.ReleaseLock(Soss.Client.CachedObjectId)"/>, 
            <see cref="M:Soss.Client.NamedCache.Update(Soss.Client.CachedObjectId,System.Object,System.Boolean)"/>, <see cref="M:Soss.Client.NamedCache.Remove(Soss.Client.CachedObjectId)"/>, or <see cref="M:Soss.Client.NamedCache.SetMetadata(Soss.Client.CachedObjectId,Soss.Client.ObjectMetadata,System.Boolean)"/>. If no subsequent call is 
            made, the lock will automatically expire after approximately 90 seconds. Passing true 
            to an object that is already locked by the same instance of the NamedCache 
            will refresh the lock by resetting the 90 second lock timeout.
            </remarks>
            <seealso cref="T:Soss.Client.ExtendedObjectMetadata"/>
            <see cref="M:Soss.Client.NamedCache.SetMetadata(Soss.Client.CachedObjectId,Soss.Client.ObjectMetadata,System.Boolean)"/>
            <exception cref="T:Soss.Client.ObjectLockedException">Thrown if <paramref name="acquireLock"/> is <c>true</c> but the object is locked by another client.</exception>
            <exception cref="T:Soss.Client.StateServerException">Thrown if ScaleOut StateServer is unavailable or has experienced an internal error.</exception>
        </member>
        <member name="M:Soss.Client.NamedCache.GetMetadata(System.Byte[],System.Boolean)">
            <summary>
            Gets the index values for an object in the named cache.
            </summary>
            <param name="id">Object identifier (must be either 16 or 32 bytes in length).</param>
            <param name="acquireLock">If true, indicates that the method should attempt to acquire a lock on the object when reading it from the server.</param>
            <returns>If the object identified by <paramref name="id"/> is found in the cache, the object's <see cref="T:Soss.Client.ExtendedObjectMetadata"/> is returned. If the object is not found in the cache, <c>null</c> is returned.</returns>
            <remarks>
            This method optionally locks the object in SOSS to prevent other clients from updating 
            or removing the object. The <see cref="P:Soss.Client.NamedCache.UseLocking"/> property is not taken into consideration by this method. If the <paramref name="acquireLock"/> parameter is true, this 
            call will block until the lock is acquired or the <see cref="P:Soss.Client.NamedCache.MaxLockAttempts"/> limit 
            has been met. The lock affects the entire object, not just its metadata, and can be released through a call to <see cref="M:Soss.Client.NamedCache.ReleaseLock(System.Byte[])"/>, 
            <see cref="M:Soss.Client.NamedCache.Update(System.Byte[],System.Object,System.Boolean)"/>, <see cref="M:Soss.Client.NamedCache.Remove(System.Byte[])"/>, or <see cref="M:Soss.Client.NamedCache.SetMetadata(System.Byte[],Soss.Client.ObjectMetadata,System.Boolean)"/>. If no subsequent call is 
            made, the lock will automatically expire after approximately 90 seconds. Passing true 
            to an object that is already locked by the same instance of the NamedCache 
            will refresh the lock by resetting the 90 second lock timeout.
            </remarks>
            <seealso cref="T:Soss.Client.ExtendedObjectMetadata"/>
            <see cref="M:Soss.Client.NamedCache.SetMetadata(System.Byte[],Soss.Client.ObjectMetadata,System.Boolean)"/>
            <exception cref="T:Soss.Client.ObjectLockedException">Thrown if <paramref name="acquireLock"/> is <c>true</c> but the object is locked by another client.</exception>
            <exception cref="T:Soss.Client.StateServerException">Thrown if ScaleOut StateServer is unavailable or has experienced an internal error.</exception>
        </member>
        <member name="M:Soss.Client.NamedCache.GetMetadata(System.String,System.Boolean)">
            <summary>
            Gets the index values for an object in the named cache.
            </summary>
            <param name="id">Object identifier.</param>
            <param name="acquireLock">If true, indicates that the method should attempt to acquire a lock on the object when reading it from the server.</param>
            <returns>If the object identified by <paramref name="id"/> is found in the cache, the object's <see cref="T:Soss.Client.ExtendedObjectMetadata"/> is returned. If the object is not found in the cache, <c>null</c> is returned.</returns>
            <remarks>
            This method optionally locks the object in SOSS to prevent other clients from updating 
            or removing the object. The <see cref="P:Soss.Client.NamedCache.UseLocking"/> property is not taken into consideration by this method. If the <paramref name="acquireLock"/> parameter is true, this 
            call will block until the lock is acquired or the <see cref="P:Soss.Client.NamedCache.MaxLockAttempts"/> limit 
            has been met. The lock affects the entire object, not just its metadata, and can be released through a call to <see cref="M:Soss.Client.NamedCache.ReleaseLock(System.String)"/>, 
            <see cref="M:Soss.Client.NamedCache.Update(System.String,System.Object,System.Boolean)"/>, <see cref="M:Soss.Client.NamedCache.Remove(System.String)"/>, or <see cref="M:Soss.Client.NamedCache.SetMetadata(System.String,Soss.Client.ObjectMetadata,System.Boolean)"/>. If no subsequent call is 
            made, the lock will automatically expire after approximately 90 seconds. Passing true 
            to an object that is already locked by the same instance of the NamedCache 
            will refresh the lock by resetting the 90 second lock timeout.
            </remarks>
            <seealso cref="T:Soss.Client.ExtendedObjectMetadata"/>
            <see cref="M:Soss.Client.NamedCache.SetMetadata(System.String,Soss.Client.ObjectMetadata,System.Boolean)"/>
            <exception cref="T:Soss.Client.ObjectLockedException">Thrown if <paramref name="acquireLock"/> is <c>true</c> but the object is locked by another client.</exception>
            <exception cref="T:Soss.Client.StateServerException">Thrown if ScaleOut StateServer is unavailable or has experienced an internal error.</exception>
        </member>
        <member name="M:Soss.Client.NamedCache.GetMetadata(System.Guid,System.Boolean)">
            <summary>
            Gets the index values for an object in the named cache.
            </summary>
            <param name="id">Object identifier.</param>
            <param name="acquireLock">If true, indicates that the method should attempt to acquire a lock on the object when reading it from the server.</param>
            <returns>If the object identified by <paramref name="id"/> is found in the cache, the object's <see cref="T:Soss.Client.ExtendedObjectMetadata"/> is returned. If the object is not found in the cache, <c>null</c> is returned.</returns>
            <remarks>
            This method optionally locks the object in SOSS to prevent other clients from updating 
            or removing the object. The <see cref="P:Soss.Client.NamedCache.UseLocking"/> property is not taken into consideration by this method. If the <paramref name="acquireLock"/> parameter is true, this 
            call will block until the lock is acquired or the <see cref="P:Soss.Client.NamedCache.MaxLockAttempts"/> limit 
            has been met. The lock affects the entire object, not just its metadata, and can be released through a call to <see cref="M:Soss.Client.NamedCache.ReleaseLock(System.Guid)"/>, 
            <see cref="M:Soss.Client.NamedCache.Update(System.Guid,System.Object,System.Boolean)"/>, <see cref="M:Soss.Client.NamedCache.Remove(System.Guid)"/>, or <see cref="M:Soss.Client.NamedCache.SetMetadata(System.Guid,Soss.Client.ObjectMetadata,System.Boolean)"/>. If no subsequent call is 
            made, the lock will automatically expire after approximately 90 seconds. Passing true 
            to an object that is already locked by the same instance of the NamedCache 
            will refresh the lock by resetting the 90 second lock timeout.
            </remarks>
            <seealso cref="T:Soss.Client.ExtendedObjectMetadata"/>
            <see cref="M:Soss.Client.NamedCache.SetMetadata(System.Guid,Soss.Client.ObjectMetadata,System.Boolean)"/>
            <exception cref="T:Soss.Client.ObjectLockedException">Thrown if <paramref name="acquireLock"/> is <c>true</c> but the object is locked by another client.</exception>
            <exception cref="T:Soss.Client.StateServerException">Thrown if ScaleOut StateServer is unavailable or has experienced an internal error.</exception>
        </member>
        <member name="M:Soss.Client.NamedCache.Retrieve(Soss.Client.CachedObjectId,System.Boolean)">
            <summary>
            Retrieves an object from the named cache.
            </summary>
            <param name="id">Object identifier.</param>
            <param name="acquireLock">Indicates that the method should attempt to acquire or refresh a lock when reading the object.</param>
            <returns>Object stored in the cache, or <c>null</c> if the object is not in the cache.</returns>
            <remarks>
            This method optionally locks the object in SOSS to prevent other clients from updating 
            or removing the object. The <see cref="P:Soss.Client.NamedCache.UseLocking"/> property is not taken into consideration by this method. If the <paramref name="acquireLock"/> parameter is true, this 
            call will block until the lock is acquired or the <see cref="P:Soss.Client.NamedCache.MaxLockAttempts"/> limit 
            has been met. The lock affects both an object and its metadata, and it can be released through a call to <see cref="M:Soss.Client.NamedCache.ReleaseLock(Soss.Client.CachedObjectId)"/>, 
            <see cref="M:Soss.Client.NamedCache.Update(Soss.Client.CachedObjectId,System.Object,System.Boolean)"/>, <see cref="M:Soss.Client.NamedCache.Remove(Soss.Client.CachedObjectId)"/>, or <see cref="M:Soss.Client.NamedCache.SetMetadata(Soss.Client.CachedObjectId,Soss.Client.ObjectMetadata,System.Boolean)"/>. If no subsequent call is 
            made, the lock will automatically expire after approximately 90 seconds. Passing true 
            to an object that is already locked by the same instance of the NamedCache 
            will refresh the lock by resetting the 90 second lock timeout.
            </remarks>
            <seealso cref="P:Soss.Client.NamedCache.Item(Soss.Client.CachedObjectId)"/>
            <seealso cref="M:Soss.Client.NamedCache.Get(Soss.Client.CachedObjectId)"/>
            <exception cref="T:Soss.Client.ObjectLockedException">Thrown if <paramref name="acquireLock"/> is <c>true</c> but the object is locked by another client.</exception>
            <exception cref="T:Soss.Client.StateServerException">Thrown if ScaleOut StateServer is unavailable or has experienced an internal error.</exception>
        </member>
        <member name="M:Soss.Client.NamedCache.Retrieve(System.Byte[],System.Boolean)">
            <summary>
            Retrieves an object from the named cache.
            </summary>
            <param name="id">Object identifier (must be either 16 or 32 bytes in length).</param>
            <param name="acquireLock">Indicates that the method should attempt to acquire or refresh a lock when reading the object.</param>
            <returns>Object stored in the cache, or <c>null</c> if the object is not in the cache.</returns>
            <remarks>
            This method optionally locks the object in SOSS to prevent other clients from updating 
            or removing the object. The <see cref="P:Soss.Client.NamedCache.UseLocking"/> property is not taken into consideration by this method. If the <paramref name="acquireLock"/> parameter is true, this 
            call will block until the lock is acquired or the <see cref="P:Soss.Client.NamedCache.MaxLockAttempts"/> limit 
            has been met. The lock affects both an object and its metadata, and it can be released through a call to <see cref="M:Soss.Client.NamedCache.ReleaseLock(System.Byte[])"/>, 
            <see cref="M:Soss.Client.NamedCache.Update(System.Byte[],System.Object,System.Boolean)"/>, <see cref="M:Soss.Client.NamedCache.Remove(System.Byte[])"/>, or <see cref="M:Soss.Client.NamedCache.SetMetadata(System.Byte[],Soss.Client.ObjectMetadata,System.Boolean)"/>. If no subsequent call is 
            made, the lock will automatically expire after approximately 90 seconds. Passing true 
            to an object that is already locked by the same instance of the NamedCache 
            will refresh the lock by resetting the 90 second lock timeout.
            </remarks>
            <seealso cref="P:Soss.Client.NamedCache.Item(System.Byte[])"/>
            <seealso cref="M:Soss.Client.NamedCache.Get(System.Byte[])"/>
            <exception cref="T:Soss.Client.ObjectLockedException">Thrown if <paramref name="acquireLock"/> is <c>true</c> but the object is locked by another client.</exception>
            <exception cref="T:Soss.Client.StateServerException">Thrown if ScaleOut StateServer is unavailable or has experienced an internal error.</exception>
        </member>
        <member name="M:Soss.Client.NamedCache.Retrieve(System.String,System.Boolean)">
            <summary>
            Retrieves an object from the named cache.
            </summary>
            <param name="id">Object identifier.</param>
            <param name="acquireLock">Indicates that the method should attempt to acquire or refresh a lock when reading the object.</param>
            <returns>Object stored in the cache, or <c>null</c> if the object is not in the cache.</returns>
            <remarks>
            This method optionally locks the object in SOSS to prevent other clients from updating 
            or removing the object. The <see cref="P:Soss.Client.NamedCache.UseLocking"/> property is not taken into consideration by this method. If the <paramref name="acquireLock"/> parameter is true, this 
            call will block until the lock is acquired or the <see cref="P:Soss.Client.NamedCache.MaxLockAttempts"/> limit 
            has been met. The lock affects both an object and its metadata, and it can be released through a call to <see cref="M:Soss.Client.NamedCache.ReleaseLock(System.String)"/>, 
            <see cref="M:Soss.Client.NamedCache.Update(System.String,System.Object,System.Boolean)"/>, <see cref="M:Soss.Client.NamedCache.Remove(System.String)"/>, or <see cref="M:Soss.Client.NamedCache.SetMetadata(System.String,Soss.Client.ObjectMetadata,System.Boolean)"/>. If no subsequent call is 
            made, the lock will automatically expire after approximately 90 seconds. Passing true 
            to an object that is already locked by the same instance of the NamedCache 
            will refresh the lock by resetting the 90 second lock timeout.
            </remarks>
            <seealso cref="P:Soss.Client.NamedCache.Item(System.String)"/>
            <seealso cref="M:Soss.Client.NamedCache.Get(System.String)"/>
            <exception cref="T:Soss.Client.ObjectLockedException">Thrown if <paramref name="acquireLock"/> is <c>true</c> but the object is locked by another client.</exception>
            <exception cref="T:Soss.Client.StateServerException">Thrown if ScaleOut StateServer is unavailable or has experienced an internal error.</exception>
        </member>
        <member name="M:Soss.Client.NamedCache.Retrieve(System.Guid,System.Boolean)">
            <summary>
            Retrieves an object from the named cache.
            </summary>
            <param name="id">Object identifier.</param>
            <param name="acquireLock">Indicates that the method should attempt to acquire or refresh a lock when reading the object.</param>
            <returns>Object stored in the cache, or <c>null</c> if the object is not in the cache.</returns>
            <remarks>
            This method optionally locks the object in SOSS to prevent other clients from updating 
            or removing the object. The <see cref="P:Soss.Client.NamedCache.UseLocking"/> property is not taken into consideration by this method. If the <paramref name="acquireLock"/> parameter is true, this 
            call will block until the lock is acquired or the <see cref="P:Soss.Client.NamedCache.MaxLockAttempts"/> limit 
            has been met. The lock affects both an object and its metadata, and it can be released through a call to <see cref="M:Soss.Client.NamedCache.ReleaseLock(System.Guid)"/>, 
            <see cref="M:Soss.Client.NamedCache.Update(System.Guid,System.Object,System.Boolean)"/>, <see cref="M:Soss.Client.NamedCache.Remove(System.Guid)"/>, or <see cref="M:Soss.Client.NamedCache.SetMetadata(System.Guid,Soss.Client.ObjectMetadata,System.Boolean)"/>. If no subsequent call is 
            made, the lock will automatically expire after approximately 90 seconds. Passing true 
            to an object that is already locked by the same instance of the NamedCache 
            will refresh the lock by resetting the 90 second lock timeout.
            </remarks>
            <seealso cref="P:Soss.Client.NamedCache.Item(System.Guid)"/>
            <seealso cref="M:Soss.Client.NamedCache.Get(System.Guid)"/>
            <exception cref="T:Soss.Client.ObjectLockedException">Thrown if <paramref name="acquireLock"/> is <c>true</c> but the object is locked by another client.</exception>
            <exception cref="T:Soss.Client.StateServerException">Thrown if ScaleOut StateServer is unavailable or has experienced an internal error.</exception>
        </member>
        <member name="M:Soss.Client.NamedCache.Get(Soss.Client.CachedObjectId)">
            <summary>
            Gets a cached object using default parameters.
            </summary>
            <param name="id">Object identifier.</param>
            <returns>The object stored in the cache, or <c>null</c> if the object is not in the cache.</returns>
            <remarks>
            <para>
            If <see cref="P:Soss.Client.NamedCache.UseLocking"/> is <c>true</c> then <see cref="M:Soss.Client.NamedCache.Get(Soss.Client.CachedObjectId)"/> will cause the object to be locked in the SOSS server, and no other clients will be able to
            acquire a lock until the lock from this instance of the NamedCache is released (either by updating the object to a new value, removing it from the cache, or calling
            <see cref="M:Soss.Client.NamedCache.ReleaseLock(Soss.Client.CachedObjectId)">ReleaseLock</see>).
            </para>
            </remarks>
            <seealso cref="P:Soss.Client.NamedCache.Item(Soss.Client.CachedObjectId)"/>
            <seealso cref="M:Soss.Client.NamedCache.Retrieve(Soss.Client.CachedObjectId,System.Boolean)"/>
        </member>
        <member name="M:Soss.Client.NamedCache.Get(System.Byte[])">
            <summary>
            Gets a cached object using default parameters.
            </summary>
            <param name="id">Object identifier (must be either 16 or 32 bytes in length).</param>
            <returns>The object stored in the cache, or <c>null</c> if the object is not in the cache.</returns>
            <remarks>
            <para>
            If <see cref="P:Soss.Client.NamedCache.UseLocking"/> is <c>true</c> then <see cref="M:Soss.Client.NamedCache.Get(System.Byte[])"/> will cause the object to be locked in the SOSS server, and no other clients will be able to
            acquire a lock until the lock from this instance of the NamedCache is released (either by updating the object to a new value, removing it from the cache, or calling
            <see cref="M:Soss.Client.NamedCache.ReleaseLock(System.Byte[])">ReleaseLock</see>).
            </para>
            </remarks>
            <seealso cref="P:Soss.Client.NamedCache.Item(System.Byte[])"/>
            <seealso cref="M:Soss.Client.NamedCache.Retrieve(System.Byte[],System.Boolean)"/>
        </member>
        <member name="M:Soss.Client.NamedCache.Get(System.String)">
            <summary>
            Gets a cached object using default parameters.
            </summary>
            <param name="id">Object identifier.</param>
            <returns>The object stored in the cache, or <c>null</c> if the object is not in the cache.</returns>
            <remarks>
            <para>
            If <see cref="P:Soss.Client.NamedCache.UseLocking"/> is <c>true</c> then <see cref="M:Soss.Client.NamedCache.Get(System.String)"/> will cause the object to be locked in the SOSS server, and no other clients will be able to
            acquire a lock until the lock from this instance of the NamedCache is released (either by updating the object to a new value, removing it from the cache, or calling
            <see cref="M:Soss.Client.NamedCache.ReleaseLock(System.String)">ReleaseLock</see>).
            </para>
            </remarks>
            <seealso cref="P:Soss.Client.NamedCache.Item(System.String)"/>
            <seealso cref="M:Soss.Client.NamedCache.Retrieve(System.String,System.Boolean)"/>
        </member>
        <member name="M:Soss.Client.NamedCache.Get(System.Guid)">
            <summary>
            Gets a cached object using default parameters.
            </summary>
            <param name="id">Object identifier.</param>
            <returns>The object stored in the cache, or <c>null</c> if the object is not in the cache.</returns>
            <remarks>
            <para>
            If <see cref="P:Soss.Client.NamedCache.UseLocking"/> is <c>true</c> then <see cref="M:Soss.Client.NamedCache.Get(System.Guid)"/> will cause the object to be locked in the SOSS server, and no other clients will be able to
            acquire a lock until the lock from this instance of the NamedCache is released (either by updating the object to a new value, removing it from the cache, or calling
            <see cref="M:Soss.Client.NamedCache.ReleaseLock(System.Guid)">ReleaseLock</see>).
            </para>
            </remarks>
            <seealso cref="P:Soss.Client.NamedCache.Item(System.Guid)"/>
            <seealso cref="M:Soss.Client.NamedCache.Retrieve(System.Guid,System.Boolean)"/>
        </member>
        <member name="M:Soss.Client.NamedCache.Get(System.Collections.IEnumerable)">
            <summary>
            Gets multiple objects from the cache based on a collection of object identifiers. No locking is performed by this overload.
            </summary>
            <remarks>
            Objects will not be locked upon retrieval through this method, even if <see cref="P:Soss.Client.NamedCache.UseLocking"/> is <c>true</c>. If there is no matching object for a specified key in the cache, it will have an entry in the returned Hashtable with a null value.
            </remarks>
            <param name="ids">An enumerable collection of object identifiers. IDs must be of type string, byte[] (16 or 32 bytes long), or CachedObjectId.</param>
            <returns>A Hashtable where keys in the collection are the supplied identifiers and whose values are the objects retrieved from the cache.</returns>
        </member>
        <member name="M:Soss.Client.NamedCache.Remove(Soss.Client.CachedObjectId)">
            <summary>
            Removes the object from the cache. No exception will be thrown and no action will be taken if the specified object does not exist in the cache.
            </summary>
            <param name="id">Object identifier.</param>
            <remarks>
            <para>
            If the cached object was previously locked via this NamedCache instance, the lock will be released if the Remove operation completes successfully.
            </para>
            <para>
            Care should be taken when performing unlocked removals of objects. An unlocked removal will not block for locks held by another clients, so other clients may have the object removed from the cache underneath them despite the locks they hold. Use the <see cref="M:Soss.Client.NamedCache.AcquireLock(Soss.Client.CachedObjectId)"/> method prior to calling <see cref="M:Soss.Client.NamedCache.Remove(Soss.Client.CachedObjectId)"/> to ensure that no other clients are holding a lock on the object.
            </para>
            </remarks>
            <exception cref="T:Soss.Client.StateServerException">Thrown if ScaleOut StateServer is unavailable or has experienced an internal error.</exception>
        </member>
        <member name="M:Soss.Client.NamedCache.Remove(System.Byte[])">
            <summary>
            Removes the object from the cache. No exception will be thrown and no action will be taken if the specified object does not exist in the cache.
            </summary>
            <param name="id">Object identifier (must be either 16 or 32 bytes in length).</param>
            <remarks>
            <para>
            If the cached object was previously locked via this NamedCache instance, the lock will be released if the Remove operation completes successfully.
            </para>
            <para>
            Care should be taken when performing unlocked removals of objects. An unlocked removal will not block for locks held by another clients, so other clients may have the object removed from the cache underneath them despite the locks they hold. Use the <see cref="M:Soss.Client.NamedCache.AcquireLock(System.Byte[])"/> method prior to calling <see cref="M:Soss.Client.NamedCache.Remove(System.Byte[])"/> to ensure that no other clients are holding a lock on the object.
            </para>
            </remarks>
            <exception cref="T:Soss.Client.StateServerException">Thrown if ScaleOut StateServer is unavailable or has experienced an internal error.</exception>
        </member>
        <member name="M:Soss.Client.NamedCache.Remove(System.String)">
            <summary>
            Removes the object from the cache. No exception will be thrown and no action will be taken if the specified object does not exist in the cache.
            </summary>
            <param name="id">Object identifier.</param>
            <remarks>
            <para>
            If the cached object was previously locked via this NamedCache instance, the lock will be released if the Remove operation completes successfully.
            </para>
            <para>
            Care should be taken when performing unlocked removals of objects. An unlocked removal will not block for locks held by another clients, so other clients may have the object removed from the cache underneath them despite the locks they hold. Use the <see cref="M:Soss.Client.NamedCache.AcquireLock(System.String)"/> method prior to calling <see cref="M:Soss.Client.NamedCache.Remove(System.String)"/> to ensure that no other clients are holding a lock on the object.
            </para>
            </remarks>
            <exception cref="T:Soss.Client.StateServerException">Thrown if ScaleOut StateServer is unavailable or has experienced an internal error.</exception>
        </member>
        <member name="M:Soss.Client.NamedCache.Remove(System.Guid)">
            <summary>
            Removes the object from the cache. No exception will be thrown and no action will be taken if the specified object does not exist in the cache.
            </summary>
            <param name="id">Object identifier.</param>
            <remarks>
            <para>
            If the cached object was previously locked via this NamedCache instance, the lock will be released if the Remove operation completes successfully.
            </para>
            <para>
            Care should be taken when performing unlocked removals of objects. An unlocked removal will not block for locks held by another clients, so other clients may have the object removed from the cache underneath them despite the locks they hold. Use the <see cref="M:Soss.Client.NamedCache.AcquireLock(System.Guid)"/> method prior to calling <see cref="M:Soss.Client.NamedCache.Remove(System.Guid)"/> to ensure that no other clients are holding a lock on the object.
            </para>
            </remarks>
            <exception cref="T:Soss.Client.StateServerException">Thrown if ScaleOut StateServer is unavailable or has experienced an internal error.</exception>
        </member>
        <member name="M:Soss.Client.NamedCache.Clear">
            <summary>
            Clears the cache.
            </summary>
            <seealso cref="M:Soss.Client.NamedCache.Remove(Soss.Client.CachedObjectId)"/>
        </member>
        <member name="M:Soss.Client.NamedCache.Contains(Soss.Client.CachedObjectId)">
            <summary>
            Checks if the cache contains an object with the given ID.
            </summary>
            <param name="id">Object identifier.</param>
            <remarks>
            <para>
            The result of the <c>Contains</c> method is only accurate at the moment of the method's invocation; other clients 
            may add or remove the object from the cache in the instant between the call to <c>Contains</c> and any subsequent 
            code. As such, the <c>Contains</c> method is not well-suited for applications which require distributed synchronization 
            and should only be used in a single-client scenario.
            </para><para>
            A safer, more reliable approach to distributed synchronization is to first attempt a retrieval of the cached object through 
            a call to <see cref="M:Soss.Client.NamedCache.Retrieve(Soss.Client.CachedObjectId,System.Boolean)"/>, which returns the object's data and optionally locks the object for exclusive use by 
            the client. If the object does not exist then it can be added to the cache by using 
            <see cref="M:Soss.Client.NamedCache.Add(Soss.Client.CachedObjectId,System.Object)"/> or <see cref="P:Soss.Client.NamedCache.Item(Soss.Client.CachedObjectId)"/>, which are safe to use
            with other clients that may be trying to add the object at the same instant. See the example in the <see cref="T:Soss.Client.NamedCache"/> 
            overview for an illustration of this pattern.
            </para>
            </remarks>
            <returns><c>true</c> if the object is in cache, otherwise <c>false</c></returns>
        </member>
        <member name="M:Soss.Client.NamedCache.Contains(System.Byte[])">
            <summary>
            Checks if the cache contains an object with the given ID.
            </summary>
            <param name="id">Object identifier (must be either 16 or 32 bytes in length).</param>
            <remarks>
            <para>
            The result of the <c>Contains</c> method is only accurate at the moment of the method's invocation; other clients 
            may add or remove the object from the cache in the instant between the call to <c>Contains</c> and any subsequent 
            code. As such, the <c>Contains</c> method is not well-suited for applications which require distributed synchronization 
            and should only be used in a single-client scenario.
            </para><para>
            A safer, more reliable approach to distributed synchronization is to first attempt a retrieval of the cached object through 
            a call to <see cref="M:Soss.Client.NamedCache.Retrieve(System.Byte[],System.Boolean)"/>, which returns the object's data and optionally locks the object for exclusive use by 
            the client. If the object does not exist then it can be added to the cache by using 
            <see cref="M:Soss.Client.NamedCache.Add(System.Byte[],System.Object)"/> or <see cref="P:Soss.Client.NamedCache.Item(System.Byte[])"/>, which are safe to use
            with other clients that may be trying to add the object at the same instant. See the example in the <see cref="T:Soss.Client.NamedCache"/> 
            overview for an illustration of this pattern.
            </para>
            </remarks>
            <returns><c>true</c> if the object is in cache, otherwise <c>false</c></returns>
        </member>
        <member name="M:Soss.Client.NamedCache.Contains(System.String)">
            <summary>
            Checks if the cache contains an object with the given ID.
            </summary>
            <param name="id">Object identifier.</param>
            <remarks>
            <para>
            The result of the <c>Contains</c> method is only accurate at the moment of the method's invocation; other clients 
            may add or remove the object from the cache in the instant between the call to <c>Contains</c> and any subsequent 
            code. As such, the <c>Contains</c> method is not well-suited for applications which require distributed synchronization 
            and should only be used in a single-client scenario.
            </para><para>
            A safer, more reliable approach to distributed synchronization is to first attempt a retrieval of the cached object through 
            a call to <see cref="M:Soss.Client.NamedCache.Retrieve(System.String,System.Boolean)"/>, which returns the object's data and optionally locks the object for exclusive use by 
            the client. If the object does not exist then it can be added to the cache by using 
            <see cref="M:Soss.Client.NamedCache.Add(System.String,System.Object)"/> or <see cref="P:Soss.Client.NamedCache.Item(System.String)"/>, which are safe to use
            with other clients that may be trying to add the object at the same instant. See the example in the <see cref="T:Soss.Client.NamedCache"/> 
            overview for an illustration of this pattern.
            </para>
            </remarks>
            <returns><c>true</c> if the object is in cache, otherwise <c>false</c></returns>
        </member>
        <member name="M:Soss.Client.NamedCache.Contains(System.Guid)">
            <summary>
            Checks if the cache contains an object with the given ID.
            </summary>
            <param name="id">Object identifier.</param>
            <remarks>
            <para>
            The result of the <c>Contains</c> method is only accurate at the moment of the method's invocation; other clients 
            may add or remove the object from the cache in the instant between the call to <c>Contains</c> and any subsequent 
            code. As such, the <c>Contains</c> method is not well-suited for applications which require distributed synchronization 
            and should only be used in a single-client scenario.
            </para><para>
            A safer, more reliable approach to distributed synchronization is to first attempt a retrieval of the cached object through 
            a call to <see cref="M:Soss.Client.NamedCache.Retrieve(System.Guid,System.Boolean)"/>, which returns the object's data and optionally locks the object for exclusive use by 
            the client. If the object does not exist then it can be added to the cache by using 
            <see cref="M:Soss.Client.NamedCache.Add(System.Guid,System.Object)"/> or <see cref="P:Soss.Client.NamedCache.Item(System.Guid)"/>, which are safe to use
            with other clients that may be trying to add the object at the same instant. See the example in the <see cref="T:Soss.Client.NamedCache"/> 
            overview for an illustration of this pattern.
            </para>
            </remarks>
            <returns><c>true</c> if the object is in cache, otherwise <c>false</c></returns>
        </member>
        <member name="M:Soss.Client.NamedCache.AcquireLock(Soss.Client.CachedObjectId)">
            <summary>
            Locks the cached object in SOSS to prevent other clients from updating or removing it.
            </summary>
            <param name="id">Object identifier.</param>
            <remarks>
            This call will block until the lock is acquired or the <see cref="P:Soss.Client.NamedCache.MaxLockAttempts"/> limit 
            has been met. The lock is released through a call to <see cref="M:Soss.Client.NamedCache.ReleaseLock(Soss.Client.CachedObjectId)"/>, 
            <see cref="M:Soss.Client.NamedCache.Update(Soss.Client.CachedObjectId,System.Object,System.Boolean)"/>, <see cref="M:Soss.Client.NamedCache.SetMetadata(Soss.Client.CachedObjectId,Soss.Client.ObjectMetadata,System.Boolean)"/>, or <see cref="M:Soss.Client.NamedCache.Remove(Soss.Client.CachedObjectId)"/>. Setting the object to a new value through <see cref="P:Soss.Client.NamedCache.Item(Soss.Client.CachedObjectId)"/> while <see cref="P:Soss.Client.NamedCache.UseLocking"/> is <c>true</c> will also cause the lock to be released. 
            If no subsequent call is made, the 
            lock will expire after approximately 90 seconds. Calling this method on an instance of 
            CachedDataAccessor that already has a lock on the cached object will reset the 90 second lock timeout.
            </remarks>
            <exception cref="T:Soss.Client.ObjectLockedException">Thrown if the object is already locked by another client.</exception>
            <exception cref="T:Soss.Client.ObjectNotFoundException">Thrown if the object does not exist.</exception>
            <exception cref="T:Soss.Client.StateServerException">Thrown if ScaleOut StateServer is unavailable or has experienced an internal error.</exception>
            <seealso cref="M:Soss.Client.NamedCache.ReleaseLock(Soss.Client.CachedObjectId)"/>
            <seealso cref="P:Soss.Client.NamedCache.UseLocking"/>
        </member>
        <member name="M:Soss.Client.NamedCache.AcquireLock(System.Byte[])">
            <summary>
            Locks the cached object in SOSS to prevent other clients from updating or removing it.
            </summary>
            <param name="id">Object identifier (must be either 16 or 32 bytes in length).</param>
            <remarks>
            This call will block until the lock is acquired or the <see cref="P:Soss.Client.NamedCache.MaxLockAttempts"/> limit 
            has been met. The lock is released through a call to <see cref="M:Soss.Client.NamedCache.ReleaseLock(System.Byte[])"/>, 
            <see cref="M:Soss.Client.NamedCache.Update(System.Byte[],System.Object,System.Boolean)"/>, <see cref="M:Soss.Client.NamedCache.SetMetadata(System.Byte[],Soss.Client.ObjectMetadata,System.Boolean)"/>, or <see cref="M:Soss.Client.NamedCache.Remove(System.Byte[])"/>. Setting the object to a new value through <see cref="P:Soss.Client.NamedCache.Item(System.Byte[])"/> while <see cref="P:Soss.Client.NamedCache.UseLocking"/> is <c>true</c> will also cause the lock to be released. 
            If no subsequent call is made, the 
            lock will expire after approximately 90 seconds. Calling this method on an instance of 
            CachedDataAccessor that already has a lock on the cached object will reset the 90 second lock timeout.
            </remarks>
            <exception cref="T:Soss.Client.ObjectLockedException">Thrown if the object is already locked by another client.</exception>
            <exception cref="T:Soss.Client.ObjectNotFoundException">Thrown if the object does not exist.</exception>
            <exception cref="T:Soss.Client.StateServerException">Thrown if ScaleOut StateServer is unavailable or has experienced an internal error.</exception>
            <seealso cref="M:Soss.Client.NamedCache.ReleaseLock(System.Byte[])"/>
            <seealso cref="P:Soss.Client.NamedCache.UseLocking"/>
        </member>
        <member name="M:Soss.Client.NamedCache.AcquireLock(System.String)">
            <summary>
            Locks the cached object in SOSS to prevent other clients from updating or removing it.
            </summary>
            <param name="id">Object identifier.</param>
            <remarks>
            This call will block until the lock is acquired or the <see cref="P:Soss.Client.NamedCache.MaxLockAttempts"/> limit 
            has been met. The lock is released through a call to <see cref="M:Soss.Client.NamedCache.ReleaseLock(System.String)"/>, 
            <see cref="M:Soss.Client.NamedCache.Update(System.String,System.Object,System.Boolean)"/>, <see cref="M:Soss.Client.NamedCache.SetMetadata(System.String,Soss.Client.ObjectMetadata,System.Boolean)"/>, or <see cref="M:Soss.Client.NamedCache.Remove(System.String)"/>. Setting the object to a new value through <see cref="P:Soss.Client.NamedCache.Item(System.String)"/> while <see cref="P:Soss.Client.NamedCache.UseLocking"/> is <c>true</c> will also cause the lock to be released. 
            If no subsequent call is made, the 
            lock will expire after approximately 90 seconds. Calling this method on an instance of 
            CachedDataAccessor that already has a lock on the cached object will reset the 90 second lock timeout.
            </remarks>
            <exception cref="T:Soss.Client.ObjectLockedException">Thrown if the object is already locked by another client.</exception>
            <exception cref="T:Soss.Client.ObjectNotFoundException">Thrown if the object does not exist.</exception>
            <exception cref="T:Soss.Client.StateServerException">Thrown if ScaleOut StateServer is unavailable or has experienced an internal error.</exception>
            <seealso cref="M:Soss.Client.NamedCache.ReleaseLock(System.String)"/>
            <seealso cref="P:Soss.Client.NamedCache.UseLocking"/>
        </member>
        <member name="M:Soss.Client.NamedCache.AcquireLock(System.Guid)">
            <summary>
            Locks the cached object in SOSS to prevent other clients from updating or removing it.
            </summary>
            <param name="id">Object identifier.</param>
            <remarks>
            This call will block until the lock is acquired or the <see cref="P:Soss.Client.NamedCache.MaxLockAttempts"/> limit 
            has been met. The lock is released through a call to <see cref="M:Soss.Client.NamedCache.ReleaseLock(System.Guid)"/>, 
            <see cref="M:Soss.Client.NamedCache.Update(System.Guid,System.Object,System.Boolean)"/>, <see cref="M:Soss.Client.NamedCache.SetMetadata(System.Guid,Soss.Client.ObjectMetadata,System.Boolean)"/>, or <see cref="M:Soss.Client.NamedCache.Remove(System.Guid)"/>. Setting the object to a new value through <see cref="P:Soss.Client.NamedCache.Item(System.Guid)"/> while <see cref="P:Soss.Client.NamedCache.UseLocking"/> is <c>true</c> will also cause the lock to be released. 
            If no subsequent call is made, the 
            lock will expire after approximately 90 seconds. Calling this method on an instance of 
            CachedDataAccessor that already has a lock on the cached object will reset the 90 second lock timeout.
            </remarks>
            <exception cref="T:Soss.Client.ObjectLockedException">Thrown if the object is already locked by another client.</exception>
            <exception cref="T:Soss.Client.ObjectNotFoundException">Thrown if the object does not exist.</exception>
            <exception cref="T:Soss.Client.StateServerException">Thrown if ScaleOut StateServer is unavailable or has experienced an internal error.</exception>
            <seealso cref="M:Soss.Client.NamedCache.ReleaseLock(System.Guid)"/>
            <seealso cref="P:Soss.Client.NamedCache.UseLocking"/>
        </member>
        <member name="M:Soss.Client.NamedCache.ReleaseLock(Soss.Client.CachedObjectId)">
            <summary>
            Releases the lock on a cached object.
            </summary>
            <remarks>Calling <see cref="M:Soss.Client.NamedCache.ReleaseLock(Soss.Client.CachedObjectId)"/> on an object that is not locked by this instance of the <see cref="T:Soss.Client.NamedCache"/> has no effect.</remarks>
            <param name="id">Object identifier.</param>
            <exception cref="T:Soss.Client.StateServerException">Thrown if ScaleOut StateServer is unavailable or has experienced an internal error.</exception>
            <seealso cref="M:Soss.Client.NamedCache.AcquireLock(Soss.Client.CachedObjectId)"/>
            <seealso cref="P:Soss.Client.NamedCache.UseLocking"/>
        </member>
        <member name="M:Soss.Client.NamedCache.ReleaseLock(System.Byte[])">
            <summary>
            Releases the lock on a cached object.
            </summary>
            <remarks>Calling <see cref="M:Soss.Client.NamedCache.ReleaseLock(System.Byte[])"/> on an object that is not locked by this instance of the <see cref="T:Soss.Client.NamedCache"/> has no effect.</remarks>
            <param name="id">Object identifier (must be either 16 or 32 bytes in length).</param>
            <exception cref="T:Soss.Client.StateServerException">Thrown if ScaleOut StateServer is unavailable or has experienced an internal error.</exception>
            <seealso cref="M:Soss.Client.NamedCache.AcquireLock(System.Byte[])"/>
            <seealso cref="P:Soss.Client.NamedCache.UseLocking"/>
        </member>
        <member name="M:Soss.Client.NamedCache.ReleaseLock(System.String)">
            <summary>
            Releases the lock on a cached object.
            </summary>
            <remarks>Calling <see cref="M:Soss.Client.NamedCache.ReleaseLock(System.String)"/> on an object that is not locked by this instance of the <see cref="T:Soss.Client.NamedCache"/> has no effect.</remarks>
            <param name="id">Object identifier.</param>
            <exception cref="T:Soss.Client.StateServerException">Thrown if ScaleOut StateServer is unavailable or has experienced an internal error.</exception>
            <seealso cref="M:Soss.Client.NamedCache.AcquireLock(System.String)"/>
            <seealso cref="P:Soss.Client.NamedCache.UseLocking"/>
        </member>
        <member name="M:Soss.Client.NamedCache.ReleaseLock(System.Guid)">
            <summary>
            Releases the lock on a cached object.
            </summary>
            <remarks>Calling <see cref="M:Soss.Client.NamedCache.ReleaseLock(System.Guid)"/> on an object that is not locked by this instance of the <see cref="T:Soss.Client.NamedCache"/> has no effect.</remarks>
            <param name="id">Object identifier.</param>
            <exception cref="T:Soss.Client.StateServerException">Thrown if ScaleOut StateServer is unavailable or has experienced an internal error.</exception>
            <seealso cref="M:Soss.Client.NamedCache.AcquireLock(System.Guid)"/>
            <seealso cref="P:Soss.Client.NamedCache.UseLocking"/>
        </member>
        <member name="M:Soss.Client.NamedCache.Query(Soss.Client.IFilter)">
            <summary>
            Queries the cache for objects that have matching metadata IndexValues as specified
            via <paramref name="filter"/>.
            </summary>
            <param name="filter">
            an <see cref="T:Soss.Client.IFilter"/> containing query criteria. An instance of <see cref="T:Soss.Client.FilterCollection"/> is suitable for this parameter.
            </param>
            <returns>IEnumerable collection of matching <see cref="T:Soss.Client.CachedObjectId"/> identifiers.</returns>
            <exception cref="T:Soss.Client.StateServerException">
            Thrown if ScaleOut StateServer is unavailable or has experienced an internal error.
            </exception>
            <example>
            <code>
            using System;
            using System.Collections;
            using Soss.Client;
            
            class Program
            {
                static void Main(string[] args)
                {
                    CacheObjectWithIndexEntry();
                    QueryForObject();
                }
            
                static void CacheObjectWithIndexEntry()
                {
                    string itemToCache = "This is an item that is stored in the shared cache.";
                    NamedCache cache = CacheFactory.GetCache("Sample Cache");
            
                    // Add the item to the cache. Setting the last parameter (lockAfterInsert) to true 
                    // causes this instance of the NamedCache to hold a lock on the object, allowing us to immediately
                    // set its index values without worrying about other clients interfering between the calls.
                    cache.Insert("ObjKey", itemToCache, new CreatePolicy(), false, true);
            
                    ObjectMetadata metadata = new ObjectMetadata();
                    metadata.IndexCollection[0] = new IndexValue("Index value 0");
                    metadata.IndexCollection[1] = new IndexValue("Index value 1");
                    // Set the index values, releasing the lock on the object:
                    cache.SetMetadata("ObjKey", metadata, true);
                }
            
                static void QueryForObject()
                {
                    NamedCache cache = CacheFactory.GetCache("Sample Cache");
            
                    // Query for the object based on one of its index values. 
                    // Leaving the other items in the FilterCollection null indicates 
                    // to the query that objects' metadata can contain any value in 
                    // that particular index.
                    FilterCollection querySpec = new FilterCollection();
                    querySpec[1] = new IndexValue("Index value 1");
                    ICollection result = cache.Query(querySpec);
            
                    // The query result contains a collection of keys that can be enumerated:
                    foreach (CachedObjectId key in result)
                    {
                        Console.WriteLine(cache[key]);
                    }
            
                    // Check that we only got the single object back.
                    System.Diagnostics.Debug.Assert(result.Count == 1);
                }
            }
            </code>
            </example>
            <seealso cref="T:Soss.Client.FilterCollection"/>
            <seealso cref="T:Soss.Client.IFilter"/>
        </member>
        <member name="M:Soss.Client.NamedCache.CreateKey(System.Byte[])">
            <summary>
            Generates a <see cref="T:Soss.Client.CachedObjectId"/> for an object identified by <paramref name="id"/>.
            </summary>
            <param name="id">Object identifier.</param>
            <returns><see cref="T:Soss.Client.CachedObjectId"/> for the given ID.</returns>
        </member>
        <member name="M:Soss.Client.NamedCache.CreateKey(System.String)">
            <summary>
            Generates a <see cref="T:Soss.Client.CachedObjectId"/> for an object identified by <paramref name="id"/>.
            </summary>
            <param name="id">Object identifier.</param>
            <returns><see cref="T:Soss.Client.CachedObjectId"/> for the given ID.</returns>
        </member>
        <member name="M:Soss.Client.NamedCache.CreateKey(System.Guid)">
            <summary>
            Generates a <see cref="T:Soss.Client.CachedObjectId"/> for an object identified by <paramref name="id"/>.
            </summary>
            <param name="id">Object identifier.</param>
            <returns><see cref="T:Soss.Client.CachedObjectId"/> for the given ID.</returns>
        </member>
        <member name="M:Soss.Client.NamedCache.CreateKey(Soss.Client.StateServerKey)">
            <summary>
            Generates a <see cref="T:Soss.Client.CachedObjectId"/> for an object identified by <paramref name="id"/>.
            </summary>
            <param name="id">A <see cref="T:Soss.Client.StateServerKey"/> identifying the State
            Server object.
            </param>
            <returns>A <see cref="T:Soss.Client.CachedObjectId"/> corresponding to the given <see cref="T:Soss.Client.StateServerKey"/>.
            </returns>
        </member>
        <member name="M:Soss.Client.NamedCache.SetCustomSerialization(Soss.Client.Serializer,Soss.Client.Deserializer)">
            <summary>
            Establishes custom serialize/deserialize callbacks for objects in this <see cref="T:Soss.Client.NamedCache"/>.
            </summary>
            <remarks>
            If <paramref name="serializer"/> and <paramref name="deserializer"/> are
            non-<c>null</c>, this NamedCache instance will use them whenever serializing or
            deserializing objects to the ScaleOut StateServer. If <paramref name="serializer"/>
            and <paramref name="deserializer"/> are both <c>null</c>, this NamedCache instance
            will use the default ScaleOut serialization mechanism. If one of <paramref name="serializer"/> or <paramref name="deserializer"/> are non-<c>null</c> and the
            other <c>null</c>, an <see cref="T:System.ArgumentNullException"/> is thrown. 
            </remarks>
            <param name="serializer"></param>
            <param name="deserializer"></param>
            <exception cref="T:System.ArgumentNullException">
            	If one of <paramref name="serializer"/> or <paramref name="deserializer"/> is <c>null</c>
            	and the other is non-<c>null</c>.
            </exception>
        </member>
        <member name="M:Soss.Client.NamedCache.SetBackingStoreAdapter(Soss.Client.IBackingStore,Soss.Client.BackingStorePolicy)">
            <summary>
            Specifies a class that can be used by the NamedCache to automatically interact with
            an external data source (a database, typically) for read-through, write-through,
            refresh-ahead, and write-behind operations. 
            </summary>
            <param name="backingStore">
            An <see cref="T:Soss.Client.IBackingStore"/> instance that implements custom logic for the retrieval
            and storage of objects in a database or other persistent data store. Setting this parameter
            to null indicates that this client should not perform any backing store operations.
            </param>
            <param name="backingStorePolicy">
            Contains options to control how a named cache interacts with a backing store.
            </param>
            <remarks>
            <para>
            Use the <see cref="M:Soss.Client.NamedCache.SetBackingStoreAdapter(Soss.Client.IBackingStore,Soss.Client.BackingStorePolicy)"/> method to enable 
            read-through, write-through, refresh-ahead, and write-behind behavior 
            when ScaleOut StateServer is being used as a cache for a persistent 
            backing store (such as a database). If backing store operations are enabled on a NamedCache, then every 
            instance of the client application that uses that NamedCache will need to register an 
            IBackingStore adapter instance using this method. Clients that fail to register an 
            adapter will not handle backing store operations assigned to them, resulting in 
            lost backing store updates and retrievals.
            </para><para>
            If read-through operations are enabled in the specified <paramref name="backingStorePolicy"/> parameter, it is not desirable for every 
            client process to simultaneously query the database when a cache miss 
            occurs. The read-through operations will affect the behavior of the 
            NamedCache's <see cref="M:Soss.Client.NamedCache.Retrieve(Soss.Client.CachedObjectId,System.Boolean)"/>, <see cref="M:Soss.Client.NamedCache.Get(Soss.Client.CachedObjectId)"/>, and <see cref="P:Soss.Client.NamedCache.Item(Soss.Client.CachedObjectId)"/> 
            methods when a cache miss occurs. The first client to perform a 
            retrieval operation on an object that is missing from the cache will have 
            its <see cref="M:Soss.Client.IBackingStore.Load(Soss.Client.CachedObjectId)"/> implementation invoked. While the 
            backing store is being queried, other clients requesting this object 
            will repeatedly poll until the object has been inserted into the cache. 
            The frequency of the polling behavior is controlled through the <see cref="P:Soss.Client.NamedCache.ReadPendingRetryInterval"/> and <see cref="P:Soss.Client.NamedCache.MaxReadThroughPendingAttempts"/> properties. 
            </para><para>
            Unlike read-through and write-through operations (which are enabled on an entire NamedCache through
            the <paramref name="backingStorePolicy"/> parameter), the asynchronous write-behind and
            refresh-ahead operations must be enabled on an object-by-object basis when they are first created in the
            ScaleOut StateServer cache. Use the <see cref="P:Soss.Client.CreatePolicy.BackingStoreMode"/> 
            property to enable write-behind or refresh-ahead operations for an object. The <see cref="P:Soss.Client.CreatePolicy.BackingStoreInterval"/>
            property controls the interval between asynchronous backing store events.
            </para><para>
            The asynchronous write-behind and refresh-ahead operations are timed 
            events that occur periodically. These operations internally make use of ScaleOut 
            StateServer's event notification feature and use the same server 
            infrastructure that implements the <see cref="E:Soss.Client.NamedCache.ObjectExpired"/> 
            event. In a server farm that is running multiple ScaleOut 
            StateServer hosts, it is not possible to predict which host will be 
            asked to perform any given refresh-ahead or write-behind operation. This 
            allows ScaleOut StateServer to maximize performance by distributing 
            backing store operations across the server farm. Again, it is important 
            to have the IBackingStore adapter implementation registered in each 
            client application to ensure that a backing store operation is not lost. If 
            the server farm is accessed solely by remote clients, there must be at 
            least as many active remote clients as there are ScaleOut hosts; this 
            ensures that all ScaleOut hosts are able to notify clients about backing 
            store operations. 
            </para><para>
            It is possible to avoid having to register an IBackingStore adapter on 
            remote client machines, but this is not a typical configuration. In 
            situations where the remote client machines do not have access to the 
            backing store but the ScaleOut StateServer host machines do have access, 
            it is permitted to avoid registering an IBackingStore adapter on the 
            remote clients (by passing <c>null</c> into the <paramref name="backingStore"/> parameter) if and only if client applications are 
            running locally on all of the ScaleOut StateServer hosts to handle 
            backing store operations. All instances of those local client 
            applications must register an IBackingStore adapter, otherwise backing 
            store events will be lost. In this configuration, all expiration and backing 
            store events will be directed to the ScaleOut StateServer hosts in the
            current version; this limitation will be removed in a future version.
            </para><para>
            This method can be called repeatedly to change the API's behavior. 
            </para>
            </remarks>
        </member>
        <member name="M:Soss.Client.NamedCache.getDA(Soss.Client.CachedObjectId)">
            <summary>
            Retrieve or construct <c>dataAccessor</c> instance.
            </summary>
            <param name="id">object id</param>
            <returns>The <c>dataAccessor</c> instance.</returns>
        </member>
        <member name="M:Soss.Client.NamedCache.CreateDataAccessor(Soss.Client.CachedObjectId)">
            <summary>
            Return a <see cref="T:Soss.Client.NamedCache.NamedCacheDataAccessor"/> initialized to access the object
            identified by <paramref name="id"/>.
            </summary>
            <remarks>
            Classes derived from <see cref="T:Soss.Client.NamedCache"/> may override this method to 
            return a derived implementation of <see cref="T:Soss.Client.NamedCache.NamedCacheDataAccessor"/>.
            </remarks>
            <param name="id">The identity of the object to be accessed.</param>
            <returns>
            A <see cref="T:Soss.Client.NamedCache.NamedCacheDataAccessor"/> initialized to access the object
            identified by <paramref name="id"/>.
            </returns>
        </member>
        <member name="M:Soss.Client.NamedCache.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection of objects in the cache.
            </summary>
            <returns>An <see cref="T:System.Collections.IEnumerator"/> for reading objects in the cache.</returns>
            <remarks>
            <para>
            The GetEnumerator method returns access to a set of objects that has been retrieved from the SOSS server. The call will result in 
            the retrieval of the entire cache from the server, and should thus be used sparingly if there are a large number of objects in the cache (so as 
            to avoid network and serialization overhead).
            </para><para>
            When searching for a particular object or subset of objects in the cache, consider using the <see cref="M:Soss.Client.NamedCache.Query(Soss.Client.IFilter)"/> method instead of a <c>foreach</c> loop.
            Querying for specific object metadata will result in less round-trips to the SOSS server.
            </para>
            </remarks>
            <example>
            <code>
            NamedCache cache = CacheFactory.GetCache("MyCache");
            
            // Use the foreach statement to hide the enumerator's complexity:
            foreach (object entry in cache)
            {
                Console.WriteLine(entry.ToString());
            }
            </code>
            </example>
        </member>
        <member name="P:Soss.Client.NamedCache.LockedDAs">
            <summary>
            Returns a per-thread Hashtable of locked DataAccessors, allocating it first
            if necessary.
            </summary>
        </member>
        <member name="P:Soss.Client.NamedCache.ApplicationNamespace">
            <summary>
            Returns the DA-level <see cref="P:Soss.Client.NamedCache.ApplicationNamespace"/> corresponding to this
            <see cref="T:Soss.Client.NamedCache"/> instance.
            </summary>
        </member>
        <member name="P:Soss.Client.NamedCache.Item(Soss.Client.CachedObjectId)">
            <summary>
            Gets or sets a cached item using default parameters.
            </summary>
            <param name="id">Identifier of the object in the cache.</param>
            <remarks>
            <para>
            If <see cref="P:Soss.Client.NamedCache.UseLocking"/> is <c>true</c> then a "get" operation will cause the object to be locked in the SOSS server, and no other clients will be able to
            acquire a lock until the lock from this instance of the NamedCache is released (either by setting the object to a new value or calling
            <see cref="M:Soss.Client.NamedCache.ReleaseLock(Soss.Client.CachedObjectId)">ReleaseLock</see>).
            </para><para>
            The "set" operation will either add a new object to the named cache (using policies defined in <see cref="P:Soss.Client.NamedCache.DefaultCreatePolicy"/>) or update an existing item with the same ID. Passing a <c>null</c> value will cause an object to be removed from the cache. The <see cref="P:Soss.Client.NamedCache.UseLocking"/> property is honored when setting a cached item to <c>null</c>, so the API will attempt to acquire a lock on the object prior to removing it if <see cref="P:Soss.Client.NamedCache.UseLocking"/> is <c>true</c>.
            </para><para>
            Note that every get/set call will cause a round trip to the SOSS service and could result in the retrieval or update of a cached object across the network.
            </para>
            </remarks>
            <returns>The object stored in the cache, or <c>null</c> if the object is not in the cache.</returns>
            <seealso cref="M:Soss.Client.NamedCache.Add(Soss.Client.CachedObjectId,System.Object)"/>
            <seealso cref="M:Soss.Client.NamedCache.Insert(Soss.Client.CachedObjectId,System.Object,Soss.Client.CreatePolicy,System.Boolean,System.Boolean)"/>
        </member>
        <member name="P:Soss.Client.NamedCache.Item(System.Byte[])">
            <summary>
            Gets or sets a cached item using default parameters.
            </summary>
            <param name="id">Identifier of the object in the cache.</param>
            <remarks>
            <para>
            If <see cref="P:Soss.Client.NamedCache.UseLocking"/> is <c>true</c> then a "get" operation will cause the object to be locked in the SOSS server, and no other clients will be able to
            acquire a lock until the lock from this instance of the NamedCache is released (either by setting the object to a new value or calling
            <see cref="M:Soss.Client.NamedCache.ReleaseLock(System.Byte[])">ReleaseLock</see>).
            </para><para>
            The "set" operation will either add a new object to the named cache (using policies defined in <see cref="P:Soss.Client.NamedCache.DefaultCreatePolicy"/>) or update an existing item with the same ID. Passing a <c>null</c> value will cause an object to be removed from the cache. The <see cref="P:Soss.Client.NamedCache.UseLocking"/> property is honored when setting a cached item to <c>null</c>, so the API will attempt to acquire a lock on the object prior to removing it if <see cref="P:Soss.Client.NamedCache.UseLocking"/> is <c>true</c>.
            </para><para>
            Note that every get/set call will cause a round trip to the SOSS service and could result in the retrieval or update of a cached object across the network.
            </para>
            </remarks>
            <returns>The object stored in the cache, or <c>null</c> if the object is not in the cache.</returns>
            <seealso cref="M:Soss.Client.NamedCache.Add(Soss.Client.CachedObjectId,System.Object)"/>
            <seealso cref="M:Soss.Client.NamedCache.Insert(Soss.Client.CachedObjectId,System.Object,Soss.Client.CreatePolicy,System.Boolean,System.Boolean)"/>
        </member>
        <member name="P:Soss.Client.NamedCache.Item(System.String)">
            <summary>
            Gets or sets a cached item using default parameters.
            </summary>
            <param name="id">Identifier of the object in the cache.</param>
            <remarks>
            <para>
            If <see cref="P:Soss.Client.NamedCache.UseLocking"/> is <c>true</c> then a "get" operation will cause the object to be locked in the SOSS server, and no other clients will be able to
            acquire a lock until the lock from this instance of the NamedCache is released (either by setting the object to a new value or calling
            <see cref="M:Soss.Client.NamedCache.ReleaseLock(System.String)">ReleaseLock</see>).
            </para><para>
            The "set" operation will either add a new object to the named cache (using policies defined in <see cref="P:Soss.Client.NamedCache.DefaultCreatePolicy"/>) or update an existing item with the same ID. Passing a <c>null</c> value will cause an object to be removed from the cache. The <see cref="P:Soss.Client.NamedCache.UseLocking"/> property is honored when setting a cached item to <c>null</c>, so the API will attempt to acquire a lock on the object prior to removing it if <see cref="P:Soss.Client.NamedCache.UseLocking"/> is <c>true</c>.
            </para><para>
            Note that every get/set call will cause a round trip to the SOSS service and could result in the retrieval or update of a cached object across the network.
            </para><para>
            Object identifiers passed into this property are hashed into keys using (by default)
            the <see cref="T:System.Security.Cryptography.SHA256Managed"/> hash algorithm prior to being sent to 
            ScaleOut StateServer. The choice of HashAlgorithm is configurable. See 
            <see cref="M:Soss.Client.ApplicationNamespace.CreateKey(System.String)"/> for details.
            </para>
            </remarks>
            <returns>The object stored in the cache, or <c>null</c> if the object is not in the cache.</returns>
            <seealso cref="M:Soss.Client.NamedCache.Add(Soss.Client.CachedObjectId,System.Object)"/>
            <seealso cref="M:Soss.Client.NamedCache.Insert(Soss.Client.CachedObjectId,System.Object,Soss.Client.CreatePolicy,System.Boolean,System.Boolean)"/>
        </member>
        <member name="P:Soss.Client.NamedCache.Item(System.Guid)">
            <summary>
            Gets or sets a cached item using default parameters.
            </summary>
            <param name="id">Identifier of the object in the cache.</param>
            <remarks>
            <para>
            If <see cref="P:Soss.Client.NamedCache.UseLocking"/> is <c>true</c> then a "get" operation will cause the object to be locked in the SOSS server, and no other clients will be able to
            acquire a lock until the lock from this instance of the NamedCache is released (either by setting the object to a new value or calling
            <see cref="M:Soss.Client.NamedCache.ReleaseLock(System.Guid)">ReleaseLock</see>).
            </para><para>
            The "set" operation will either add a new object to the named cache (using policies defined in <see cref="P:Soss.Client.NamedCache.DefaultCreatePolicy"/>) or update an existing item with the same ID. Passing a <c>null</c> value will cause an object to be removed from the cache. The <see cref="P:Soss.Client.NamedCache.UseLocking"/> property is honored when setting a cached item to <c>null</c>, so the API will attempt to acquire a lock on the object prior to removing it if <see cref="P:Soss.Client.NamedCache.UseLocking"/> is <c>true</c>.
            </para><para>
            Note that every get/set call will cause a round trip to the SOSS service and could result in the retrieval or update of a cached object across the network.
            </para>
            </remarks>
            <returns>The object stored in the cache, or <c>null</c> if the object is not in the cache.</returns>
            <seealso cref="M:Soss.Client.NamedCache.Add(Soss.Client.CachedObjectId,System.Object)"/>
            <seealso cref="M:Soss.Client.NamedCache.Insert(Soss.Client.CachedObjectId,System.Object,Soss.Client.CreatePolicy,System.Boolean,System.Boolean)"/>
        </member>
        <member name="P:Soss.Client.NamedCache.AllowClientCaching">
             <summary>
             Gets/sets an flag indicating whether (deserialized) objects accessed by this cache should be kept 
             in a client-side cache when they are written to StateServer. Default is <c>true</c>.
             </summary>
             <remarks>
             <para>
             To maximize access performance, SOSS adds an internal cache for deserialized data objects within its .NET client 
             libraries. When reading objects, this client-side cache reduces access response time by eliminating data motion and 
             deserialization overhead for objects that have not been updated in the SOSS distributed store. The 
             AllowClientCaching property controls whether the NamedCache will take advantage of this behavior.
             </para>
             <para>
             The contents of the deserialized cache will automatically be invalidated if the object is changed or removed 
             by any of the servers in the farm, so it will never return a stale version of the shared object. The client 
             libraries always check with the SOSS service prior to returning the object in order to make sure that the 
             deserialized version is up-to-date. While this check does involve a round-trip to the service, it is still 
             much faster than retrieving and deserializing the entire object.
             </para>
             <para>
             By default, AllowClientCaching is set to <c>true</c>. Set this property to <c>false</c> prior to adding
             or updating an object in the cache to prevent a deserialized copy of the object from being stored in
             the .NET client library. Setting AllowClientCaching to <c>false</c> also ensures that any deserialized 
             copies that were previously held by this client will no longer be used.
             </para>
             <para>
             The size of the deserialized cache is determined by the max_client_cache parameter in the soss_params.txt 
             file (located in the ScaleOut StateServer program directory). By default, the cache can consume up to 100000 KB  
             (100 MB) of memory. Once the limit has been met, the least recently used items will be purged from the cache to make
             way for new items. Setting the max_client_cache parameter to 0 will disable the deserialized cache entirely, 
             even if AllowClientCaching is <c>true</c>.
             </para><para>
             <strong>Guidelines for Using the Deserialized Cache</strong>
             </para><para>
             The deserialized client cache, which is enabled by default, is a collection of object references retained by the SOSS client library to accelerate multiple retrieve accesses to an object stored in the SOSS service.  Changes made by client code to an object held in the deserialized cache may cause the deserialized cache to return the changed object on a subsequent retrieve instead of the version that is stored in the SOSS service.
             </para><para>
             The deserialized cache is only intended to be used with either read-only access or in a locked retrieve/update usage pattern. In the retrieve/update usage pattern, an object stored in the SOSS service is retrieved and locked, optionally updated, and then unlocked (either by the update or by an explicit unlock access). This pattern enables multiple processes on the same or different servers to reliably update a shared object. No changes should be made to the retrieved object outside of the retrieve/update pair because these changes would not be propagated to the distributed cache.
             </para><para>
             Sometimes a client application may want to retrieve an object from SOSS, make some changes to the object, and then discard it after using it without persisting the changes to the SOSS service. This usage model can cause the deserialized cache to get out of sync with SOSS. If an application requires that changes be made to a retrieved object outside of the above read/update usage pattern, steps should be taken to avoid corrupting the deserialized cache. Either the cache should be disabled by setting the <see cref="P:Soss.Client.NamedCache.AllowClientCaching"/> property to <c>false</c>, or a deep copy of the retrieved object should be made with changes made only to this copy. Doing this will keep the locally cached object from getting out of sync with the authoritative object that is kept in the SOSS service.
             </para>
             <example>
             <code>
             NamedCache cache = CacheFactory.GetCache("myCache");
            
             // Setting the AllowClientCaching property to false before updating/adding it 
             // will ensure that the object will not be stored in the client-side cache:
             cache.AllowClientCaching = false;
             cache.Add("myObjId", "This is an object in the named cache.");
             </code>
             </example>
             </remarks>
        </member>
        <member name="P:Soss.Client.NamedCache.UseLocking">
            <summary>
            Determines the locking behavior when using the NamedCache's indexer to get or set cached items. Default is <c>false</c>.
            </summary>
            <remarks>
            <para>
            The UseLocking property causes the NamedCache's <see cref="P:Soss.Client.NamedCache.Item(Soss.Client.CachedObjectId)"/> accessor to lock the cached object
            in the SOSS server in order to prevent other clients from performing locked operations. Performing a get
            operation will cause the client to acquire a lock, and performing a set operation will cause the lock to be released.
            </para><para>
            This property also affects the <see cref="M:Soss.Client.NamedCache.Get(System.String)"/> method. It does not affect the locking behavior of the
            <see cref="M:Soss.Client.NamedCache.Retrieve(System.String,System.Boolean)"/>, <see cref="M:Soss.Client.NamedCache.Update(System.String,System.Object,System.Boolean)"/>, or <see cref="M:Soss.Client.NamedCache.Insert(System.String,System.Object,Soss.Client.CreatePolicy,System.Boolean,System.Boolean)"/> 
            methods, which allow for fine-grained locking control.
            </para>
            </remarks>
            <seealso cref="P:Soss.Client.NamedCache.UseLocking"/>
        </member>
        <member name="P:Soss.Client.NamedCache.DefaultCreatePolicy">
            <summary>
            Gets/sets the <see cref="T:Soss.Client.CreatePolicy"/> object used as parameters when adding objects to the cache using the
            <see cref="M:Soss.Client.NamedCache.Add(Soss.Client.CachedObjectId,System.Object)"/> method or <see cref="P:Soss.Client.NamedCache.Item(Soss.Client.CachedObjectId)"/>.
            </summary>
            <remarks>
            <para>
            When a NamedCache instance is created, objects added to the cache via <see cref="M:Soss.Client.NamedCache.Add(Soss.Client.CachedObjectId,System.Object)"/> and <see cref="P:Soss.Client.NamedCache.Item(Soss.Client.CachedObjectId)"/> will have an infinite <see cref="P:Soss.Client.CreatePolicy.TimeoutMinutes">timeout</see> and a sliding <see cref="P:Soss.Client.CreatePolicy.IsAbsoluteTimeout">expiration</see> policy. 
            Also, objects will be subject to <see cref="P:Soss.Client.CreatePolicy.PreemptionPriority">reclamation</see> under low-memory circumstances (if reclamation is enabled in the server), and they will eligible for GeoServer <see cref="P:Soss.Client.CreatePolicy.AllowReplication">replication</see> 
            to a remote store. New defaults can be established by setting the <see cref="P:Soss.Client.NamedCache.DefaultCreatePolicy"/> property to a new <see cref="T:Soss.Client.CreatePolicy"/> instance.
            </para><para>
            Policies set by the <see cref="P:Soss.Client.NamedCache.DefaultCreatePolicy"/> property can be overridden on an object-by-object basis by adding those objects to the cache via the <see cref="M:Soss.Client.NamedCache.Insert(System.String,System.Object,Soss.Client.CreatePolicy,System.Boolean,System.Boolean)"/> method.
            </para><para>
            Objects added to the cache with a <see cref="P:Soss.Client.CreatePolicy.PreemptionPriority"/> of Normal will only be removed under low memory situations if LRU functionality is enabled in StateServer. Edit the soss_params.txt file in the StateServer installation directory to enable this feature: the lru_threshold parameter should be set to a percentage of the max_memory parameter. Eligible objects will be deleted using a least recently used algorithm once memory usage has passed the threshold.
            </para>
            </remarks>
            <seealso cref="P:Soss.Client.NamedCache.UseLocking"/>
        </member>
        <member name="P:Soss.Client.NamedCache.Keys">
            <summary>
            Returns a collection of keys for all the objects stored in the named cache.
            </summary>
            <seealso cref="P:Soss.Client.NamedCache.Values"/>
        </member>
        <member name="P:Soss.Client.NamedCache.Values">
            <summary>
            Returns the values of all objects stored in cache.
            </summary>
            <remarks>
            <para>
            The <see cref="P:Soss.Client.NamedCache.Values"/> property implementation first retrieves the set of keys
            for all objects in the cache. The objects corresponding to those keys are lazily
            retrieved from StateServer as they are requested via the <see cref="P:Soss.Client.NamedCache.Values"/>' <see cref="T:System.Collections.IEnumerator"/>. It is possible that an oject that existed at the time the
            keys were retrieved may no longer exist at the time the the <see cref="P:Soss.Client.NamedCache.Values"/>
            enumerator is asked to retrieve it. In that case, a <c>null</c> will be returned
            for the current value in the enumeration.
            </para><para>
            Care should be taken when calling this property on a large cache. Retrieval of a
            large set of objects may cause high network usage between ScaleOut hosts and may
            also cause high CPU overhead from deserializing many objects.
            </para>
            </remarks>
            <seealso cref="P:Soss.Client.NamedCache.Keys"/>
        </member>
        <member name="P:Soss.Client.NamedCache.Count">
            <summary>
            Gets the number of elements contained in the cache.
            </summary>
            <remarks>
            This property will cause a round trip to the ScaleOut service and invoke a parallel query on the entire distributed cache. Client applications should not use this property frequently or for trivial purposes.
            </remarks>
        </member>
        <member name="P:Soss.Client.NamedCache.MaxLockAttempts">
            <summary>
            Gets/Sets the number of lock attempts. The default is 200 attempts. 
            </summary>
            <remarks>
            <para>
            The NamedCache will repeatedly attempt to acquire a lock in situations where another client 
            already has a lock on the object. This property determines the number of times the NamedCache attempts to acquire a 
            lock when a locking operation is performed before the method throws a <see cref="T:Soss.Client.ObjectLockedException"/>. 
            <see cref="M:Soss.Client.NamedCache.AcquireLock(Soss.Client.CachedObjectId)"/>, getting via <see cref="P:Soss.Client.NamedCache.Item(Soss.Client.CachedObjectId)"/> (when <see cref="P:Soss.Client.NamedCache.UseLocking"/> is <c>true</c>), 
            and <see cref="M:Soss.Client.NamedCache.Retrieve(Soss.Client.CachedObjectId,System.Boolean)">Retrieve(true)</see> all repeatedly attempt to acquire locks in this manner. 
            The default is 200 attempts.
            </para><para>
            Use the <see cref="P:Soss.Client.NamedCache.LockRetryInterval"/> property to set the amount of time between retries.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if the property is set to a value less than 1.</exception>
            <seealso cref="P:Soss.Client.NamedCache.LockRetryInterval"/>
        </member>
        <member name="P:Soss.Client.NamedCache.LockRetryInterval">
            <summary>
            Gets/Sets milliseconds between lock retries. Default is 500 milliseconds.
            </summary>
            <remarks>
            <para>
            The NamedCache will repeatedly attempt to acquire a lock in situations where another client 
            already has a lock on the object. The LockRetryInterval property gets or sets the amount of time (in milliseconds) 
            between attempts to acquire an exclusive lock on the cached object using 
            <see cref="M:Soss.Client.NamedCache.AcquireLock(Soss.Client.CachedObjectId)"/>, getting via <see cref="P:Soss.Client.NamedCache.Item(Soss.Client.CachedObjectId)"/> (when <see cref="P:Soss.Client.NamedCache.UseLocking"/> is <c>true</c>), 
            and <see cref="M:Soss.Client.NamedCache.Retrieve(Soss.Client.CachedObjectId,System.Boolean)">Retrieve(true)</see>. The default value is 500 milliseconds.
            </para><para>
            The number of retries is determined by the <see cref="P:Soss.Client.NamedCache.MaxLockAttempts"/> property.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if the property is set to a value less than 0.</exception>
            <seealso cref="P:Soss.Client.NamedCache.MaxLockAttempts"/>
        </member>
        <member name="P:Soss.Client.NamedCache.MaxReadThroughPendingAttempts">
            <summary>
            Gets/Sets the number of read attempts made when another client has a backing store read-through operation pending. The default is 2400 attempts. 
            </summary>
            <remarks>
            <para>
            The NamedCache will repeatedly attempt to read an object from the SOSS server in situations where another client 
            is concurrently preforming a read-through operation from a database or other backing store. This property determines 
            the number of times the NamedCache attempts to read the object from the cache before the method throws a <see cref="T:Soss.Client.ReadThroughTimeoutException"/>. 
            The default is 2400 attempts.
            </para><para>
            Paramaters to the <see cref="M:Soss.Client.NamedCache.SetBackingStoreAdapter(Soss.Client.IBackingStore,Soss.Client.BackingStorePolicy)"/> determine whether a NamedCache automatically tries to perform
            read-through operations.
            </para><para>
            Use the <see cref="P:Soss.Client.NamedCache.LockRetryInterval"/> property to set the amount of time between retries.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if the property is set to a value less than 1.</exception>
            <seealso cref="P:Soss.Client.NamedCache.ReadPendingRetryInterval"/>
        </member>
        <member name="P:Soss.Client.NamedCache.ReadPendingRetryInterval">
            <summary>
            Gets/Sets milliseconds between read retries when backing store read-through operations are enabled. Default is 50 milliseconds.
            </summary>
            <remarks>
            <para>
            The NamedCache will repeatedly attempt to read an object from the SOSS server in situations where another client 
            is concurrently preforming a read-through operation from a database or other backing store. The ReadPendingRetryInterval property gets or sets the amount of time (in milliseconds) 
            between attempts to retrieve the object from the cache. The default value is 50 milliseconds.
            </para><para>
            The number of retries is determined by the <see cref="P:Soss.Client.NamedCache.MaxReadThroughPendingAttempts"/> property.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if the property is set to a value less than 0.</exception>
            <seealso cref="P:Soss.Client.NamedCache.MaxReadThroughPendingAttempts"/>
        </member>
        <member name="P:Soss.Client.NamedCache.Name">
            <summary>
            Return this <see cref="T:Soss.Client.NamedCache"/>'s name.
            </summary>
        </member>
        <member name="P:Soss.Client.NamedCache.EnableObjectExpirationEventHandling">
            <summary>
            Gets or sets a value indicating whether this <see cref="T:Soss.Client.NamedCache"/> instance is
            enabled for StateServer object expiration events. 
            </summary>
            <remarks>
            When retrieving the value of <see cref="P:Soss.Client.NamedCache.EnableObjectExpirationEventHandling"/>, the
            value returned indicates whether StateServer object expiration events are being
            received for this <see cref="T:Soss.Client.NamedCache"/>'s StateServer application (for any
            reason). More specifically, the value <c>true</c> will be returned from this
            property if any of the following are true:
            <para>
            <list type="bullet">
            	<item>
            	<see cref="P:Soss.Client.NamedCache.EnableObjectExpirationEventHandling"/> has previously been set to
            	<c>true</c> and has not subsequently been set to <c>false</c>.
            	</item>
            	<item>
            	an <see cref="E:Soss.Client.NamedCache.ObjectExpired"/> event handler has been established on this <see cref="T:Soss.Client.NamedCache"/>
            	</item>
            	<item>
            	Parallel method invocations are in use on this <see cref="T:Soss.Client.NamedCache"/>
            	instance.
            	</item>
            	<item>
            	In the Grid Computing Edition of State Server, the <see cref="!:EnableMethodInvocationEventHandling"/> property has been set to
                <c>true</c> and has not subsequently been set to <c>false</c>.
            	</item>
            </list>
            </para>
            Conversely, if all of the above are false, <see cref="P:Soss.Client.NamedCache.EnableObjectExpirationEventHandling"/> will return <c>false</c>.
            <para>
            Note that it is not necessary to set this property to <c>true</c> to begin
            receiving object expiration notifications on your event handler. Simply registering
            for the event is sufficient.
            </para>
            </remarks>
            <seealso cref="E:Soss.Client.NamedCache.ObjectExpired"/>
        </member>
        <member name="E:Soss.Client.NamedCache.ObjectExpired">
            <summary>
            An event that is fired when an object cached within this <see cref="T:Soss.Client.NamedCache"/> expires.
            </summary>
            <remarks><para>
            The event-handling feature must be enabled in the ScaleOut StateServer service in order for this 
            event to fire. This feature is enabled by default -- the <em>max_event_tries</em> 
            parameter in the soss_params.txt file (located in the StateServer installation directory) 
            controls eventing in the StateServer service. See the "Configuration Parameters" topic in the 
            SOSS Help file for details on the soss_params.txt file.
            </para><para>
            Note that in a server farm that is running multiple ScaleOut hosts, it is not possible to predict 
            which host will receive the event. This allows ScaleOut StateServer to maximize performance by 
            distributing events across the server farm. It is important to have the event-handling code running 
            on each ScaleOut server to ensure that the expiration event is not lost. If the server farm is 
            accessed solely by remote clients, there must be at least as many active remote clients as there 
            are ScaleOut hosts; this ensures that all ScaleOut hosts can deliver events to a client. This 
            requirement applies to all applications that perform event handling.
            </para><para>
            The <see cref="T:Soss.Client.CacheFactory"/> creates one and only one <see cref="T:Soss.Client.NamedCache"/> instance for any
            given application name. If you create a custom factory that creates <see cref="T:Soss.Client.NamedCache"/> subclass
            instances, you could adopt a different policy. If there is more than one <see cref="T:Soss.Client.NamedCache"/>
            instance for a given application name, you may establish an event handler on any instance and 
            have it run if an ObjectExpired event is delivered to this client for the given application. In that
            case, the "sender" parameter of the <see cref="T:Soss.Client.NamedCache.ObjectExpiredEventHandler"/> callback will be set to the
            first <see cref="T:Soss.Client.NamedCache"/> instance on which an event handler was registered.
            </para><para>
            Cached objects can be added to the cache with either an absolute or a sliding expiration scheme; 
            retrieving or updating an object will reset the object's timeout if it uses a sliding expiration.
            </para>
            </remarks>
            <example>
            <code>
            using System;
            using Soss.Client;
            
            class ExpirationSample
            {
                static void Main(string[] args)
                {
                    // Get access to the named cache "Sample Cache"
                    NamedCache cache = CacheFactory.GetCache("Sample Cache");
            		// Register an event handler on the cache instance.
            		cache.ObjectExpired += new NamedCache.ObjectExpiredEventHandler(NamedCache_ObjectExpired);
            
                    // Create an object with a one minute lifetime:
                    CreatePolicy cachePolicy = new CreatePolicy(1);
                    cache.Insert("MyObjKey", "This is a cached object", cachePolicy, false, false);
                    Console.WriteLine("The object was created.");
            
                    // Wait for the object to expire so our program has a chance to receive the event.
                    System.Threading.Thread.Sleep(70000);
                }
            
                static void NamedCache_ObjectExpired(object sender, NamedCacheObjExpiredEventArgs eventArgs)
                {
                    // Examine the expiring object:
                    NamedCache cache = CacheFactory.GetCache("Sample Cache");
                    Console.WriteLine("An object with the following value has expired: " + cache[eventArgs.CachedObjectId]);
            
                    // Choose between removing the object or allowing it to remain:
                    eventArgs.NamedCacheObjDisposition = NamedCacheObjDisposition.Remove;
                }
            }
            </code>
            </example>
        </member>
        <member name="P:Soss.Client.NamedCache.SerializationCallbacks">
            <summary>
            Return the <see cref="P:Soss.Client.NamedCache.SerializationCallbacks"/> in use for this <see cref="T:Soss.Client.NamedCache"/> instance. If <c>null</c>, the default serialization mechanism
            will be used.
            </summary>
        </member>
        <member name="T:Soss.Client.NamedCache.ObjectExpiredEventHandler">
            <summary>
            Delegate used by the ObjectExpired event.
            </summary>
        </member>
        <member name="T:Soss.Client.NamedCache.SerializationCallbackHolder">
            <summary>
            A holder for a pair of callback methods for serializing and deserializing objects
            written to StateServer. We hold them in a separate class to ensure they get updated
            and referenced atomically.
            </summary>
        </member>
        <member name="F:Soss.Client.NamedCache.SerializationCallbackHolder.Serializer">
            <summary>
            The <see cref="F:Soss.Client.NamedCache.SerializationCallbackHolder.Serializer"/> callback.
            </summary>
        </member>
        <member name="F:Soss.Client.NamedCache.SerializationCallbackHolder.Deserializer">
            <summary>
            The <see cref="F:Soss.Client.NamedCache.SerializationCallbackHolder.Deserializer"/> callback.
            </summary>
        </member>
        <member name="M:Soss.Client.NamedCache.SerializationCallbackHolder.#ctor(Soss.Client.Serializer,Soss.Client.Deserializer)">
            <summary>
            Create a new <see cref="T:Soss.Client.NamedCache.SerializationCallbackHolder"/> instance with the supplied
            <paramref name="serializer"/> and <paramref name="deserializer"/>.
            </summary>
            <param name="serializer">the serializer to use</param>
            <param name="deserializer">the deserializer to use</param>
        </member>
        <member name="M:Soss.Client.NamedCache.SerializationCallbackHolder.op_Implicit(Soss.Client.NamedCache.SerializationCallbackHolder)~Soss.Client.Serializer">
            <summary>
            An implicit cast operator from a <see cref="T:Soss.Client.NamedCache.SerializationCallbackHolder"/> to
            a <see cref="F:Soss.Client.NamedCache.SerializationCallbackHolder.Serializer"/>. 
            </summary>
            <param name="holder">the <see cref="T:Soss.Client.NamedCache.SerializationCallbackHolder"/> to convert from</param>
            <returns>
            	the <see cref="F:Soss.Client.NamedCache.SerializationCallbackHolder.Serializer"/> held by this holder or <c>null</c> if
                <paramref name="holder"/> is <c>null</c>.
            </returns>
        </member>
        <member name="M:Soss.Client.NamedCache.SerializationCallbackHolder.op_Implicit(Soss.Client.NamedCache.SerializationCallbackHolder)~Soss.Client.Deserializer">
            <summary>
            An implicit cast operator from a <see cref="T:Soss.Client.NamedCache.SerializationCallbackHolder"/> to
            a <see cref="F:Soss.Client.NamedCache.SerializationCallbackHolder.Deserializer"/>. 
            </summary>
            <param name="holder">the <see cref="T:Soss.Client.NamedCache.SerializationCallbackHolder"/> to convert from</param>
            <returns>
            	the <see cref="F:Soss.Client.NamedCache.SerializationCallbackHolder.Deserializer"/> held by this holder or <c>null</c> if
                <paramref name="holder"/> is <c>null</c>.
            </returns>
        </member>
        <member name="T:Soss.Client.NamedCache.NamedCacheDataAccessor">
            <summary>
            A derived <see cref="T:Soss.Client.DataAccessor"/> used to access objects within a
            <see cref="T:Soss.Client.NamedCache"/>.
            </summary>
            <remarks>
            This implementation tracks object locking behavior to ensure that once a 
            thread locks an object, the same <see cref="T:Soss.Client.DataAccessor"/> is used by that
            thread for that object until the object is unlocked.
            </remarks>
        </member>
        <member name="M:Soss.Client.NamedCache.NamedCacheDataAccessor.#ctor(Soss.Client.StateServerKey)">
            <summary>
            Creates a new <see cref="T:Soss.Client.NamedCache.NamedCacheDataAccessor"/> instance initialized to
            access the object identified by <paramref name="key"/>.
            </summary>
            <remarks>
            This constructor is used by the DataAccessor CacheFactory when creating a
            DataAccessor to deserialized an object created via a <see cref="T:Soss.Client.NamedCache"/>.
            </remarks>
            <param name="key">
            	the <see cref="T:Soss.Client.StateServerKey"/> that identifies the object to be managed
                by this <see cref="T:Soss.Client.NamedCache.NamedCacheDataAccessor"/>.
            </param>
        </member>
        <member name="M:Soss.Client.NamedCache.NamedCacheDataAccessor.#ctor(Soss.Client.CachedObjectId)">
            <summary>
            Creates a new <see cref="T:Soss.Client.NamedCache.NamedCacheDataAccessor"/> instance initialized 
            to access the object identified by <paramref name="id"/> using the default
            serialization supported by <see cref="T:Soss.Client.DataAccessor"/>.
            </summary>
            <param name="id">
            	the <see cref="T:Soss.Client.CachedObjectId"/> of the object to be managed by this <see cref="T:Soss.Client.NamedCache.NamedCacheDataAccessor"/>
            </param>
        </member>
        <member name="M:Soss.Client.NamedCache.NamedCacheDataAccessor.#ctor(Soss.Client.CachedObjectId,Soss.Client.NamedCache.SerializationCallbackHolder)">
            <summary>
            Creates a new <see cref="T:Soss.Client.NamedCache.NamedCacheDataAccessor"/> instance initialized 
            to access the object identified by <paramref name="id"/>.
            </summary>
            <param name="id">
            	the <see cref="T:Soss.Client.CachedObjectId"/> of the object to be managed by this <see cref="T:Soss.Client.NamedCache.NamedCacheDataAccessor"/>
            </param>
            <param name="serializationCallbacks">
            	the serialize/deserialize pair to use when accessing the object within the
                StateServer.
            </param>
        </member>
        <member name="M:Soss.Client.NamedCache.NamedCacheDataAccessor.Serialize(System.IO.Stream,System.Object)">
            <summary>
            Serialize the given object <paramref name="obj"/> into the provided
            <see cref="T:System.IO.Stream"/>.
            </summary>
            <remarks>
            <para>
            If the <see cref="T:Soss.Client.NamedCache"/> instance that created this DataAccessor had
            a custom serializer established via the <see cref="M:Soss.Client.NamedCache.SetCustomSerialization(Soss.Client.Serializer,Soss.Client.Deserializer)"/>,
            then this subclass will use the supplied serializer. Otherwise, it will delegate
            to the default serializer.
            </para>
            </remarks>
        </member>
        <member name="M:Soss.Client.NamedCache.NamedCacheDataAccessor.Deserialize(System.IO.Stream)">
            <summary>
            Deserialize an object previously serialized with <see cref="M:Soss.Client.NamedCache.NamedCacheDataAccessor.Serialize(System.IO.Stream,System.Object)"/>
            from the provided <see cref="T:System.IO.Stream"/>, returning the original object.
            </summary>
            <remarks>
            <para>
            If the <see cref="T:Soss.Client.NamedCache"/> instance that created this DataAccessor had
            a custom deserializer established via the <see cref="M:Soss.Client.NamedCache.SetCustomSerialization(Soss.Client.Serializer,Soss.Client.Deserializer)"/>,
            then this subclass will use the supplied deserializer. Otherwise, it will delegate
            to the default deserializer.
            </para>
            </remarks>
        </member>
        <member name="M:Soss.Client.NamedCache.NamedCacheDataAccessor.OnLocked">
            <summary>
            Called by the <see cref="T:Soss.Client.DataAccessor"/> base class when it locks an object.
            </summary>
            <remarks>
            Derived classes must delegate to their base class implementation to ensure 
            correct operation.
            </remarks>
        </member>
        <member name="M:Soss.Client.NamedCache.NamedCacheDataAccessor.OnUnlocked">
            <summary>
            Called by the <see cref="T:Soss.Client.DataAccessor"/> base class when it unlocks an object.
            </summary>
            <remarks>
            Derived classes must delegate to their base class implementation to ensure 
            correct operation.
            </remarks>
        </member>
        <member name="M:Soss.Client.NamedCache.NamedCacheDataAccessor.OnLockRefreshed">
            <summary>
            Called by the <see cref="T:Soss.Client.DataAccessor"/> base class when an existing lock is
            refreshed.
            </summary>
            <remarks>
            Derived classes must delegate to their base class implementation to ensure 
            correct operation.
            </remarks>
        </member>
        <member name="T:Soss.Client.NamedCache.NamedCacheDataAccessor.AgingList">
            <summary>
            A doubly-linked least-recently-used list holding all <see cref="T:Soss.Client.NamedCache.NamedCacheDataAccessor"/>s currently
            held in some thread's <see cref="P:Soss.Client.NamedCache.LockedDAs"/> <see cref="T:System.Collections.Hashtable"/>. 
            </summary>
            <remarks>
            This list is managed as an LRU by the <see cref="M:Soss.Client.NamedCache.NamedCacheDataAccessor.OnLocked"/>, <see cref="M:Soss.Client.NamedCache.NamedCacheDataAccessor.OnUnlocked"/>, 
            <see cref="M:Soss.Client.NamedCache.NamedCacheDataAccessor.OnLockRefreshed"/> methods. A background timer thread runs at intervals of 
            <see cref="F:Soss.Client.NamedCache.NamedCacheDataAccessor.GuaranteedLockExpirationTime"/> to find <see cref="T:Soss.Client.NamedCache.NamedCacheDataAccessor.AgingListEntry"/> instances
            older than <see cref="F:Soss.Client.NamedCache.NamedCacheDataAccessor.GuaranteedLockExpirationTime"/> still in the list. Those entries are
            removed and the associated <see cref="T:Soss.Client.NamedCache.NamedCacheDataAccessor"/> instances are removed
            from the relevant per-thread hashtable.
            </remarks>
        </member>
        <member name="T:Soss.Client.NamedCache.NamedCacheDataAccessor.AgingListEntry">
            <summary>
            Holds a single, doubly-linked entry in an <see cref="T:Soss.Client.NamedCache.NamedCacheDataAccessor.AgingList"/>.
            </summary>
        </member>
        <member name="T:Soss.Client.BackingStorePolicy">
            <summary>
            Contains options to control how a named cache interacts with a backing store. A <see cref="T:Soss.Client.BackingStorePolicy"/> is associated with a 
            <see cref="T:Soss.Client.NamedCache"/> and <see cref="T:Soss.Client.IBackingStore"/> instance though a call to <see cref="M:Soss.Client.NamedCache.SetBackingStoreAdapter(Soss.Client.IBackingStore,Soss.Client.BackingStorePolicy)"/>. 
            </summary>
            <remarks>
            <para>
            The <see cref="T:Soss.Client.BackingStorePolicy"/> class controls read-through, write-through, refresh-ahead, and write-behind
            behavior when ScaleOut StateServer is being used as cache for a persistent backing store (such as a database). Use the 
            <see cref="P:Soss.Client.BackingStorePolicy.EnableAsyncOperations"/> property to enable asynchronous refresh-ahead and write-behind operations.
            </para><para>
            If read-through operations are enabled, it is not desirable for every client process to simultaeously query the database when a cache miss occurs, so the 
            <see cref="P:Soss.Client.BackingStorePolicy.EnableReadThrough"/> property will affect the behavior of the NamedCaches's <see cref="M:Soss.Client.NamedCache.Retrieve(Soss.Client.CachedObjectId,System.Boolean)"/>, 
            <see cref="M:Soss.Client.NamedCache.Get(Soss.Client.CachedObjectId)"/>, and <see cref="P:Soss.Client.NamedCache.Item(Soss.Client.CachedObjectId)"/> methods when a cache miss occurs. The first client to perform a retrieval 
            operation on an object that's missing from the cache will have its <see cref="M:Soss.Client.IBackingStore.Load(Soss.Client.CachedObjectId)"/> implementation invoked. While the 
            backing store is being queried, other clients requesting this object will repeatedly poll until the object has been inserted into the cache. The frequency of the
            polling behavior is controlled through the NamedCache's <see cref="P:Soss.Client.NamedCache.ReadPendingRetryInterval"/> and <see cref="P:Soss.Client.NamedCache.MaxReadThroughPendingAttempts"/> properties.
            </para><para>
            The <see cref="P:Soss.Client.BackingStorePolicy.EnableWriteThrough"/> property is used to indicate to the StateServer that the client will be performing write-through operations via an 
            implementation of <see cref="M:Soss.Client.IBackingStore.Store(Soss.Client.CachedObjectId,System.Object)"/>.
            </para><para>
            Changing properties of the <see cref="T:Soss.Client.BackingStorePolicy"/> after a call to <see cref="M:Soss.Client.NamedCache.SetBackingStoreAdapter(Soss.Client.IBackingStore,Soss.Client.BackingStorePolicy)"/> will not change
            the named cache's behavior--<see cref="M:Soss.Client.NamedCache.SetBackingStoreAdapter(Soss.Client.IBackingStore,Soss.Client.BackingStorePolicy)"/> must be called again for the new policy options to take 
            effect.
            </para>
            </remarks>
        </member>
        <member name="M:Soss.Client.BackingStorePolicy.#ctor">
            <summary>
            Creates a BackingStorePolicy object with all options set to <c>false</c>.
            </summary>
        </member>
        <member name="M:Soss.Client.BackingStorePolicy.#ctor(System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Creates a BackingStorePolicy object.
            </summary>
            <param name="enableAsyncOperations">Indicates whether this client will handle asynchronous refresh-ahead/write-behind operations.</param>
            <param name="enableReadThrough">
            If <c>true</c>, a client will populate the StateServer automatically from a database (or 
            other type of backing store) when a cache miss occurs by invoking the <see cref="M:Soss.Client.IBackingStore.Load(Soss.Client.CachedObjectId)"/>
            method.
            </param>
            <param name="enableWriteThrough">
            If <c>true</c>, a client will synchronously write changes to a database (or 
            other type of backing store) when a cached object is updated or created in the cache 
            by invoking the <see cref="M:Soss.Client.IBackingStore.Store(Soss.Client.CachedObjectId,System.Object)"/>
            method.
            </param>
        </member>
        <member name="P:Soss.Client.BackingStorePolicy.EnableAsyncOperations">
            <summary>
            Indicates whether this client will handle asynchronous refresh-ahead/write-behind operations.
            </summary>
        </member>
        <member name="P:Soss.Client.BackingStorePolicy.EnableReadThrough">
            <summary>
            If <c>true</c>, a client will populate the StateServer automatically from a database (or 
            other type of backing store) when a cache miss occurs by invoking the <see cref="M:Soss.Client.IBackingStore.Load(Soss.Client.CachedObjectId)"/>
            method.
            </summary>
        </member>
        <member name="P:Soss.Client.BackingStorePolicy.EnableWriteThrough">
            <summary>
            If <c>true</c>, a client will synchronously write changes to a database (or 
            other type of backing store) when a cached object is updated or created in the cache 
            by invoking the <see cref="M:Soss.Client.IBackingStore.Store(Soss.Client.CachedObjectId,System.Object)"/>
            method.
            </summary>
        </member>
        <member name="T:Soss.Client.NamedCacheObjDisposition">
            <summary>
            An enumeration used to indicate to the cache whether to save or remove an object upon return from a <see cref="E:Soss.Client.NamedCache.ObjectExpired"/> event handler.
            </summary>
        </member>
        <member name="F:Soss.Client.NamedCacheObjDisposition.Save">
            <summary>
            The client would like to keep the object in the store.
            </summary>
        </member>
        <member name="F:Soss.Client.NamedCacheObjDisposition.Remove">
            <summary>
            The client would like the object removed from the store. 
            </summary>
        </member>
        <member name="T:Soss.Client.NamedCacheEventCode">
            <summary>
            An enumeration containing the event codes providing the reason an event was fired. 
            </summary>
        </member>
        <member name="F:Soss.Client.NamedCacheEventCode.LowMemory">
            <summary>
            A preemptable object was removed from memory due to a low memory condition.
            </summary>
        </member>
        <member name="F:Soss.Client.NamedCacheEventCode.ObjectTimeout">
            <summary>
            An object's timeout expired. 
            </summary>
        </member>
        <member name="F:Soss.Client.NamedCacheEventCode.Dependency">
            <summary>
            An object is being removed due to a dependency change.
            </summary>
        </member>
        <member name="T:Soss.Client.NamedCacheObjExpiredEventArgs">
            <summary>
            An EventArgs subclass that contains information specific to event handlers handling cached object expiration events.
            </summary>
            <remarks>
            Object expiration event handlers may indicate to the shared cache that an expired object should not be deleted by setting <see cref="T:Soss.Client.ObjectDisposition"/> to Save.
            </remarks>
        </member>
        <member name="P:Soss.Client.NamedCacheObjExpiredEventArgs.NamedCache">
            <summary>
            Returns a NamedCache instance that can be used to manipulate the expiring cached object.
            </summary>
        </member>
        <member name="P:Soss.Client.NamedCacheObjExpiredEventArgs.AppId">
            <summary>
            Gets the Application ID corresponding to the affected cached object. 
            </summary>
        </member>
        <member name="P:Soss.Client.NamedCacheObjExpiredEventArgs.Key">
            <summary>
            Returns the StateServerKey structure used by StateServer to identify the expiring cached object.
            </summary>
        </member>
        <member name="P:Soss.Client.NamedCacheObjExpiredEventArgs.NamedCacheObjDisposition">
            <summary>
            Gets or sets a value indicating what the cache should do with the object after the event handler runs. 
            </summary>
        </member>
        <member name="P:Soss.Client.NamedCacheObjExpiredEventArgs.CachedObjectId">
            <summary>
            Returns the CachedObjectId of the expiring object.
            </summary>
        </member>
        <member name="P:Soss.Client.NamedCacheObjExpiredEventArgs.NamedCacheEventCode">
            <summary>
            Returns the reason the event was fired.
            </summary>
        </member>
        <member name="M:Soss.Client.BulkInsertRunner.DoBulkInsert(System.Collections.IDictionary,Soss.Client.NamedCache,System.Boolean,Soss.Client.Serializer)">
            <summary>
            Starts a bulk insert operation.
            </summary>
        </member>
        <member name="M:Soss.Client.BulkInsertRunner.DoWork(System.Object)">
            <summary>
            Method invoked by thread pool to insert items into the cache. Treats the IDictionary passed into 
            DoBulkInsert() like a work queue. All the ThreadPool workers share an enumerator on the IDictionary
            to pick up the next object to insert into SOSS.
            </summary>
            <param name="state">Not used.</param>
        </member>
        <member name="M:Soss.Client.BulkInsertRunner.InsertObject(System.Collections.DictionaryEntry,Soss.Client.CreateInfo,System.Boolean)">
            <summary>
            Takes a DictionaryEntry from the IDictionary passed into DoBulkInsert() and inserts
            the key/value pair into SOSS. If the value happens to be a SossObjectDescriptor type then
            we used the metadata and CreateInfo in there when adding the object. If the DictionaryEntry.Value
            is null then we try to delete the associated object from the cache.
            </summary>
            <param name="entry">DictionaryEntry containing an object and a value.</param>
            <param name="defaultCreateInfo">CreateInfo to use if the value isn't a SossObjectDescriptor with its own CreateInfo.</param>
            <param name="addToClientCache">Indicates whether to add objects to the client cache.</param>
        </member>
        <member name="M:Soss.Client.BulkInsertRunner.GetKey(System.Object)">
            <summary>
            Turns various data types into a StateServerKey.
            </summary>
        </member>
        <member name="T:Soss.Client.BulkAddException">
            <summary>
            A <see cref="T:Soss.Client.StateServerException"/> specialization that indicates that 
            one or more failures occured during a bulk <see cref="M:Soss.Client.NamedCache.Add(System.Collections.IDictionary)"/> operation.
            </summary>
        </member>
        <member name="M:Soss.Client.BulkAddException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <exclude/>
        </member>
        <member name="T:Soss.Client.CreatePolicy">
            <summary>
            The <see cref="T:Soss.Client.CreatePolicy"/> class provides extended parameter information to the <see cref="M:Soss.Client.NamedCache.Insert(System.String,System.Object,Soss.Client.CreatePolicy,System.Boolean,System.Boolean)"/> method and <see cref="P:Soss.Client.NamedCache.DefaultCreatePolicy"/> property. This class allows you to specify the StateServer object timeout, the type of timeout, whether the object may be removed from memory if memory availability becomes constrained, and any dependencies this object has on other StateServer objects.
            </summary>
        </member>
        <member name="M:Soss.Client.CreatePolicy.#ctor">
            <summary>
            Creates a CreatePolicy object with an infinite timeout. 
            Also, objects will be subject to reclamation under low-memory circumstances, and they will eligible for GeoServer replication 
            to a remote store.
            </summary>
        </member>
        <member name="M:Soss.Client.CreatePolicy.#ctor(System.Int32)">
            <summary>
            Creates a CreatePolicy object with a sliding timeout of the specified duration. Objects created with this CreatePolicy will be subject to reclamation under low-memory circumstances, and they will elibible for GeoServer replication 
            to a remote store.
            </summary>
            <param name="timeoutMinutes">Number of minutes before the object expires. 0 for an infinite timeout.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown if <paramref name="timeoutMinutes"/> is set to a value less than 0 or 
            greater than 69,905.
            </exception>
        </member>
        <member name="M:Soss.Client.CreatePolicy.#ctor(System.TimeSpan)">
            <summary>
            Creates a CreatePolicy object with a sliding timeout of the specified duration. Objects created with this CreatePolicy will be subject to reclamation under low-memory circumstances, and they will elibible for GeoServer replication 
            to a remote store.
            </summary>
            <param name="timeout">Time until the object expires, with a minimum granularity of one second. Use <see cref="F:System.TimeSpan.Zero"/> for an infinite timeout.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown if <paramref name="timeout"/> is set to a value less than 0 seconds or 
            greater than 4,194,303 seconds (69,905 minutes).
            </exception>
        </member>
        <member name="M:Soss.Client.CreatePolicy.#ctor(System.Int32,System.Boolean)">
            <summary>
            Creates a CreatePolicy object with a timeout of the specified duration that is either sliding or absolute. Objects created with this CreatePolicy will be subject to reclamation under low-memory circumstances, and they will elibible for GeoServer replication 
            to a remote store.
            </summary>
            <param name="timeoutMinutes">Number of minutes before the object expires. 0 for an infinite timeout.</param>
            <param name="isAbsoluteTimeout">Indicates whether the timeout is an absolute expiration value or is a sliding expiration value that gets reset every time the object is accessed.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown if <paramref name="timeoutMinutes"/> is set to a value less than 0 or 
            greater than 69,905.
            </exception>
        </member>
        <member name="M:Soss.Client.CreatePolicy.#ctor(System.TimeSpan,System.Boolean)">
            <summary>
            Creates a CreatePolicy object with a timeout of the specified duration that is either sliding or absolute. Objects created with this CreatePolicy will be subject to reclamation under low-memory circumstances, and they will elibible for GeoServer replication 
            to a remote store.
            </summary>
            <param name="timeout">Time until the object expires, with a minimum granularity of one second. Use <see cref="F:System.TimeSpan.Zero"/> for an infinite timeout.</param>
            <param name="isAbsoluteTimeout">Indicates whether the timeout is an absolute expiration value or is a sliding expiration value that gets reset every time the object is accessed.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown if <paramref name="timeout"/> is set to a value less than 0 seconds or 
            greater than 4,194,303 seconds (69,905 minutes).
            </exception>
        </member>
        <member name="M:Soss.Client.CreatePolicy.#ctor(System.Int32,System.Boolean,Soss.Client.ObjectPreemptionPriority,System.Object[],System.Boolean)">
            <summary>
            Creates a CreatePolicy object.
            </summary>
            <param name="timeoutMinutes">Number of minutes before the object expires. 0 for an infinite timeout.</param>
            <param name="isAbsoluteTimeout">Indicates whether the timeout is an absolute expiration value or is a sliding expiration value that gets reset every time the object is accessed.</param>
            <param name="preemptionPriority">Indicates the priority of keeping the object in the cache during low-memory situations. Removable objects are removed from memory when memory runs low based on a least recently used algorithm.</param>
            <param name="dependencies">Keys to objects on which the object being added depends. Items in the array must be of type string, byte[], Guid, <see cref="T:Soss.Client.CachedObjectId"/>, or <see cref="T:Soss.Client.StateServerKey"/>. An object can be dependent upon up to 2 parent objects. Keys to parents that do not exist in the store will be ignored.</param>
            <param name="allowReplication">Indicates whether the object to be added to the cache will be subject to GeoServer cross-store replication.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown if <paramref name="timeoutMinutes"/> is set to a value less than 0 or 
            greater than 69,905.
            </exception>
        </member>
        <member name="M:Soss.Client.CreatePolicy.#ctor(System.TimeSpan,System.Boolean,Soss.Client.ObjectPreemptionPriority,System.Object[],System.Boolean)">
            <summary>
            Creates a CreatePolicy object.
            </summary>
            <param name="timeout">Time until the object expires, with a minimum granularity of one second. Use <see cref="F:System.TimeSpan.Zero"/> for an infinite timeout.</param>
            <param name="isAbsoluteTimeout">Indicates whether the timeout is an absolute expiration value or is a sliding expiration value that gets reset every time the object is accessed.</param>
            <param name="preemptionPriority">Indicates the priority of keeping the object in the cache during low-memory situations. Removable objects are removed from memory when memory runs low based on a least recently used algorithm.</param>
            <param name="dependencies">Keys to objects on which the object being added depends. Items in the array must be of type string, byte[], Guid, <see cref="T:Soss.Client.CachedObjectId"/>, or <see cref="T:Soss.Client.StateServerKey"/>. An object can be dependent upon up to 2 parent objects. Keys to parents that do not exist in the store will be ignored.</param>
            <param name="allowReplication">Indicates whether the object to be added to the cache will be subject to GeoServer cross-store replication.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown if <paramref name="timeout"/> is set to a value less than 0 seconds or 
            greater than 4,194,303 seconds (69,905 minutes).
            </exception>
        </member>
        <member name="M:Soss.Client.CreatePolicy.GenerateCreateInfo(System.UInt32)">
            <summary>
            Internal function used to convert a CreatePolicy object into a CreateInfo struct. Transforms dependency keys of various
            types into StateServerKeys. Dependencies should only be established between objects in the same named cache, so all 
            dependency keys use the same appID as the object being created.
            </summary>
            <param name="appId"></param>
            <returns></returns>
        </member>
        <member name="P:Soss.Client.CreatePolicy.TimeoutMinutes">
            <summary>
            Gets/sets the timeout until the object expires, rounded to the nearest minute. 0 for an infinite timeout.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown if TimeoutMinutes is set to a value less than 0 or 
            greater than 69,905.
            </exception>
        </member>
        <member name="P:Soss.Client.CreatePolicy.Timeout">
            <summary>
            Gets/sets the timeout until the object expires, with a minimum granularity of one second. Use <see cref="F:System.TimeSpan.Zero"/> for an infinite timeout.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown if Timeout is set to a value less than 0 seconds or 
            greater than 4,194,303 seconds (69,905 minutes).
            </exception>
        </member>
        <member name="P:Soss.Client.CreatePolicy.IsAbsoluteTimeout">
            <summary>
            Gets/sets whether the timeout is an absolute expiration value or is a sliding expiration value that gets reset every time the object is accessed.
            </summary>
        </member>
        <member name="P:Soss.Client.CreatePolicy.IsAbsoluteTimeoutOnRead">
            <summary>
            Gets/sets whether the timeout is an absolute expiration value or is a sliding expiration value that gets reset every time the object updated. (This 
            property is overridden by the <see cref="P:Soss.Client.CreatePolicy.IsAbsoluteTimeout"/> property, which resets the expiration if the object is updated or read.)
            </summary>
        </member>
        <member name="P:Soss.Client.CreatePolicy.PreemptionPriority">
            <summary>
            Gets/sets the priority of keeping the object in the cache during low-memory situations. Removable objects are removed from memory when memory runs low based on a least recently used algorithm.
            </summary>
        </member>
        <member name="P:Soss.Client.CreatePolicy.Dependencies">
            <summary>
            Gets/sets keys to objects on which the object being added depends. Items in the array must be of type string, byte[], Guid, or <see cref="T:Soss.Client.StateServerKey"/>. An object can be dependent upon up to 2 parent objects. Keys to parents that do not exist in the store will be ignored.
            </summary>
        </member>
        <member name="P:Soss.Client.CreatePolicy.AllowReplication">
            <summary>
            Gets/sets whether the object to be added to the cache will be subject to GeoServer cross-store replication.
            </summary>
        </member>
        <member name="P:Soss.Client.CreatePolicy.BackingStoreMode">
            <summary>
            Gets/sets the associated object's <see cref="T:Soss.Client.BackingStoreAsyncPolicy"/>. Default is <see cref="F:Soss.Client.BackingStoreAsyncPolicy.None"/>.
            </summary>
        </member>
        <member name="P:Soss.Client.CreatePolicy.BackingStoreInterval">
            <summary>
            Gets/sets the interval between asynchronous backing store events (refresh-ahead, write-behind).
            </summary>
            <remarks>
            The default value of this property is 4 minutes. The minimum granularity for is 1 second; 
            if the specified TimeSpan contains a millisecond component then it will be rounded to the nearest second.
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown if BackingStoreInterval is set to a value less than 1 second or 
            greater than 4,194,303 seconds (69,905 minutes).
            </exception>
        </member>
        <member name="T:Soss.Client.CachedObjectId">
            <summary>
            The CachedObjectId class serves as an identifier for a cached object in a <see cref="T:Soss.Client.NamedCache"/> collection. 
            </summary>
            <remarks>
            CachedObjectIds are created by a <see cref="T:Soss.Client.NamedCache"/>, and are valid for use with that
            <see cref="T:Soss.Client.NamedCache"/>. <see cref="T:Soss.Client.NamedCache"/> supports methods for constructing
            <see cref="T:Soss.Client.CachedObjectId"/>s from String, Byte[], or Guid identifier values.
            </remarks>
            <seealso cref="M:Soss.Client.NamedCache.CreateKey(System.String)"/>
            <seealso cref="M:Soss.Client.NamedCache.CreateKey(System.Byte[])"/>
            <seealso cref="M:Soss.Client.NamedCache.CreateKey(System.Guid)"/>
        </member>
        <member name="M:Soss.Client.CachedObjectId.Equals(Soss.Client.CachedObjectId)">
            <summary>
            Determines whether two <see cref="T:Soss.Client.CachedObjectId"/> instances are equal.
            </summary>
            <param name="other">The <see cref="T:Soss.Client.CachedObjectId"/> to compare with the current <see cref="T:Soss.Client.CachedObjectId"/> instance.</param>
            <returns>
            <c>true</c> if the specified <see cref="T:Soss.Client.CachedObjectId"/> is equal to the current <see cref="T:Soss.Client.CachedObjectId"/>; 
            otherwise, <c>false</c>.
            </returns>
            <remarks>
            <see cref="M:Soss.Client.CachedObjectId.Equals(Soss.Client.CachedObjectId)"/> does not check for reference equality; rather, it checks to see 
            if both CachedObjectId instances identify the same object in the ScaleOut StateServer store.
            </remarks>
        </member>
        <member name="M:Soss.Client.CachedObjectId.#ctor(Soss.Client.StateServerKey)">
            <summary>
            Creates a new CachedObjectId instance from <see cref="T:Soss.Client.StateServerKey"/>. The application ID is ignored.
            </summary>
            <param name="key">The <see cref="T:Soss.Client.StateServerKey"/> associated with the object in the cache.</param>
            <exception cref="T:System.NotSupportedException">Thrown if <paramref name="key"/> is a session key.</exception>
        </member>
        <member name="M:Soss.Client.CachedObjectId.Equals(System.Object)">
            <summary>
            Determines whether two <see cref="T:Soss.Client.CachedObjectId"/> instances are equal.
            </summary>
            <param name="o">The <see cref="T:System.Object"/> to compare with the current <see cref="T:Soss.Client.CachedObjectId"/>.</param>
            <returns><c>true</c> if the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:Soss.Client.CachedObjectId"/>; otherwise, <c>false</c>.</returns>
            <remarks>
            <see cref="M:Soss.Client.CachedObjectId.Equals(System.Object)"/> does not check for reference equality; rather, it checks to see if 
            <paramref name="o"/> is a <see cref="T:Soss.Client.CachedObjectId"/> and if so, whether 
            both <see cref="T:Soss.Client.CachedObjectId"/> instances identify the same object in the ScaleOut StateServer store.
            </remarks>
        </member>
        <member name="M:Soss.Client.CachedObjectId.op_Equality(Soss.Client.CachedObjectId,Soss.Client.CachedObjectId)">
            <summary>
            Compares two <see cref="T:Soss.Client.CachedObjectId"/> instances for equality.
            </summary>
            <remarks>
            <see cref="T:Soss.Client.CachedObjectId"/>s are compared for equality by value: they are 
            considered equal if they identify the same object in the ScaleOut StateServer store.
            </remarks>
            <param name="a">The first <see cref="T:Soss.Client.CachedObjectId"/> to compare.</param>
            <param name="b">The second <see cref="T:Soss.Client.CachedObjectId"/> to compare.</param>
            <returns>
            <c>true</c> if <paramref name="a"/> and <paramref name="b"/> identify the
            same object in the ScaleOut StateServer store. Otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Soss.Client.CachedObjectId.op_Inequality(Soss.Client.CachedObjectId,Soss.Client.CachedObjectId)">
            <summary>
            Compares two <see cref="T:Soss.Client.CachedObjectId"/> instances for inequality.
            </summary>
            <remarks>
            <see cref="T:Soss.Client.CachedObjectId"/>s are compared for inequality by value: they are 
            considered to be not equal if they identify different objects in the ScaleOut 
            StateServer store.
            </remarks>
            <param name="a">The first <see cref="T:Soss.Client.CachedObjectId"/> to compare.</param>
            <param name="b">The second <see cref="T:Soss.Client.CachedObjectId"/> to compare.</param>
            <returns>
            <c>false</c> if <paramref name="a"/> and <paramref name="b"/> identify the
            same object in the ScaleOut StateServer store. Otherwise, <c>true</c>.
            </returns>
        </member>
        <member name="M:Soss.Client.CachedObjectId.GetHashCode">
            <summary>
            Overrides GetHashCode method.
            </summary>
            <returns>Return hashcode for <see cref="T:Soss.Client.CachedObjectId"/> instance. </returns>
        </member>
        <member name="M:Soss.Client.CachedObjectId.ToString">
            <summary>
            Returns a string representing this key.
            </summary>
            <returns>A string representation of this key.</returns>
        </member>
        <member name="M:Soss.Client.CachedObjectId.GetStringKey">
            <summary>
            Retrieves the original (unhashed) string used as a key to a StateServer
            object.
            </summary>
            <returns>
            A <see cref="T:System.String"/> value that was provided as a key when the associated object
            was created. Returns <c>null</c> if the object is not in the cache or if the key
            to the object was created with a datatype other than <see cref="T:System.String"/>.
            </returns>
            <remarks>
            <para>
            This call may cause a round-trip to the StateServer if the CachedObjectId
            in question was not constructed by the user with the orignal string. (That 
            is, if the CachedObjectId instance was provided to the user in an expiration event as an EventArg
            or in an asynchronous database read-ahead/write-behind handler then the GetKeyString method may need to perform a 
            round-trip to the server to retrieve the original key.)
            </para><para>
            This method should not be used to check for the existence of an object in the cache.
            </para>
            </remarks>
        </member>
        <member name="P:Soss.Client.CachedObjectId.Key">
            <summary>
            The <see cref="T:Soss.Client.StateServerKey"/> representing the key of a cached object. Read-only.
            </summary>
            <remarks>
            This property provides access to the underlying <see cref="T:Soss.Client.StateServerKey"/> structure that is being 
            used by the CachedObjectId instance to access the object in the ScaleOut StateServer service.
            </remarks> 
        </member>
        <member name="P:Soss.Client.CachedObjectId.AppId">
            <summary>
            Return the Application ID corresponding to the StateServerKey wrapped by this
            <see cref="T:Soss.Client.CachedObjectId"/>.
            </summary>
        </member>
        <member name="T:Soss.Client.StringResources">
             <summary>
             A strongly-typed means of looking up resource names. 
             </summary>
             <remarks>
             This is similar to the
             approach taken in Whidbey.
             <para>
            	I use the following VisualStudio macro to find the names of the resources in
            	the corresponding .resx file and generate the corresponding property to look
            	up the name in the resource and return the corresponding string.
             <code>
            	Imports EnvDTE
            	Imports System.Diagnostics
            	Imports System.IO
            	Imports System.Resources
            	Imports System.Collections
            
            	Public Module ResxNameToProperty
            		' uses the name of the current file to figure out the name of the
            		' resx file.
            
            		Public Sub GenProperties()
            			Dim modulePath As String = DTE.ActiveDocument.FullName
            			Dim resxName As String = Path.ChangeExtension(modulePath, ".resx")
            
            			Dim reader As ResXResourceReader = New ResXResourceReader(resxName)
            			Dim sel As TextSelection = DTE.ActiveDocument.Selection()
            			sel.Delete()
            			Dim de As DictionaryEntry
            			For Each de In reader
            				Dim propDeclaration As String
            				propDeclaration = vbTab + vbTab + "public static string " + de.Key + " { get { return GetString(""" + de.Key + """); } }" + vbNewLine
            				sel.TopPoint.CreateEditPoint.Insert(propDeclaration)
            			Next
            		End Sub
            	End Module
             </code>
             </para>
             </remarks>
        </member>
        <member name="T:Soss.Client.IBackingStore">
            <summary>
            Provides a means for a named cache to interact with a backing store (such as a database) to perform read-through, write-though, refresh-ahead,
            and write-behind operations.
            </summary>
            <example>
            <code>
            using System;
            using System.Data.SqlClient;
            using Soss.Client;
            
            class Program
            {
                // Configures a named cache to use read-through operations to automatically populate a cache and
                // refresh-ahead operations to refresh its contents every 5 seconds.
                static void Main(string[] args)
                {
                    NamedCache priceCache = CacheFactory.GetCache("Prices");
            
                    // Configure the "Prices" cache for backing store support by setting its DefaultCreatePolicy and then 
                    // associating an IBackingStore instance with the named cache using SetBackingStoreAdapter(). This only
                    // needs to be done at the application's startup--subsequent calls to CacheFactory.GetCache("Prices") 
                    // will return the same NamedCache instance with the same backing store configuration.
            
                    priceCache.DefaultCreatePolicy.BackingStoreMode = BackingStoreAsyncPolicy.RefreshAhead;
                    priceCache.DefaultCreatePolicy.BackingStoreInterval = TimeSpan.FromSeconds(5);
            
                    BackingStoreAdapter adapter = new BackingStoreAdapter();
                    priceCache.SetBackingStoreAdapter(adapter, new BackingStorePolicy(true, true, false));
            
                    // Retrieve an object from the cache. Read-through will transparently retrieve it from the DB:
                    decimal toyPrice = (decimal)priceCache["TickleMeElmo"];
            
                    Console.WriteLine(toyPrice);
                    Console.WriteLine("Hit enter to stop.");
                    Console.ReadLine();
                }
            }
            
            class BackingStoreAdapter : IBackingStore
            {
                const string connString = "Data Source=localhost;Initial Catalog=BackingStoreSample;Integrated Security=true";
            
                public object Load(CachedObjectId id)
                {
                    Console.WriteLine("Loading/refreshing {0} price in cache.", id.GetStringKey());
                    string cmdText = string.Format("SELECT Price FROM PriceList WHERE ProductId = '{0}'", id.GetStringKey());
                    SqlConnection conn = new SqlConnection(connString);
                    SqlCommand selectCommand = new SqlCommand(cmdText, conn);
                    conn.Open();
                    decimal price = (decimal)selectCommand.ExecuteScalar();
                    conn.Close();
            
                    return price;
                }
            
                public void Store(CachedObjectId id, object value)
                {
                    // The value parameter is the price value being stored in the cache.
                    string cmdText = string.Format("UPDATE PriceList SET Price = {0} WHERE ObjectId = '{1}'", value.ToString(), id.GetStringKey());
                    SqlConnection conn = new SqlConnection(connString);
                    SqlCommand updateCommand = new SqlCommand(cmdText, conn);
                    conn.Open();
                    updateCommand.ExecuteNonQuery();
                    conn.Close();
                }
            
                public void Erase(CachedObjectId id)
                {
                    // This Erase method won't ever be invoked because we haven't enabled write-through or write-behind. It's defined
                    // here for illustrative purposes.
                    string cmdText = string.Format("DELETE FROM PriceList WHERE ProductId = '{0}'", id.GetStringKey());
                    SqlConnection conn = new SqlConnection(connString);
                    SqlCommand delCommand = new SqlCommand(cmdText, conn);
                    conn.Open();
                    delCommand.ExecuteNonQuery();
                    conn.Close();
                }
            
                public CreatePolicy GetCreatePolicy(CachedObjectId id)
                {
                    // Returning null causes read-through to use the NamedCache's default create policy when
                    // adding the object to the cache.
                    return null;
                }
            }
            </code>
            </example>
        </member>
        <member name="M:Soss.Client.IBackingStore.Load(Soss.Client.CachedObjectId)">
            <summary>
            Loads an object from the backing store. Returns <c>null</c> if there is no value in the backing store for the specified id.
            </summary>
            <param name="id">The identifier of the object to retrieve.</param>
            <returns>The object from the backing store that is to be loaded into ScaleOut StateServer.</returns>
        </member>
        <member name="M:Soss.Client.IBackingStore.Store(Soss.Client.CachedObjectId,System.Object)">
            <summary>
            Persists an object to the backing store.
            </summary>
            <param name="id">The identifier of the object to persist.</param>
            <param name="value">The cached object to be written to the backing store.</param>
        </member>
        <member name="M:Soss.Client.IBackingStore.Erase(Soss.Client.CachedObjectId)">
            <summary>
            Removes an object from the backing store.
            </summary>
            <param name="id">The identifier of the object to delete.</param>
        </member>
        <member name="M:Soss.Client.IBackingStore.GetCreatePolicy(Soss.Client.CachedObjectId)">
            <summary>
            Provides a policy object to be used when a <see cref="M:Soss.Client.IBackingStore.Load(Soss.Client.CachedObjectId)"/> operation inserts an object into the named cache. If the method returns 
            <c>null</c> then the named cache's <see cref="P:Soss.Client.NamedCache.DefaultCreatePolicy"/> will be used.
            </summary>
            <param name="id">The identifier of the object to be loaded into the cache.</param>
            <returns>
            The <see cref="T:Soss.Client.CreatePolicy"/> to be used when inserting the specified object into the cache or <c>null</c> if the named cache's
            <see cref="P:Soss.Client.NamedCache.DefaultCreatePolicy"/> is to be used.
            </returns>
        </member>
        <member name="T:Soss.Client.CacheFactory">
            <summary>
            Provides access to a collection of cached objects that is identified by a provided 
            cache name. The <see cref="M:Soss.Client.CacheFactory.GetCache(System.String)"/> method must be used to 
            instantiate a <see cref="T:Soss.Client.NamedCache"/> collection.
            </summary>
            <remarks>
            For any given cache name, the <see cref="T:Soss.Client.CacheFactory"/> maintains a single <see cref="T:Soss.Client.NamedCache"/>
            instance. That instance is returned for any requests for a <see cref="T:Soss.Client.NamedCache"/> of the
            given name. In particular, properties specified on a <see cref="T:Soss.Client.NamedCache"/> instance immediately
            affect all users of the given <see cref="T:Soss.Client.NamedCache"/>.
            </remarks>
            <example>
            <code>
            using System;
            using Soss.Client;
            
            class Program
            {
                static void Main(string[] args)
                {
                    // Use the cache factory to access a named cache in the StateServer object store:
                    NamedCache cache = CacheFactory.GetCache("namedCache");
                    
                    // Add an object to the cache:
                    cache.Add("key", "This is an object in the named cache.");
            
                    // Read and lock the object in the server:
                    cache.Retrieve("key", true);
            
                    // Update and unlock:
                    cache.Update("key", "This is an update to the object", true);
                    
                    // Remove from the cache:
                    cache.Remove("key");
                }
            }
            </code>
            </example>
        </member>
        <member name="F:Soss.Client.CacheFactory.SOSSLIB_MAX_APP_ID">
            <summary>
            Maximum value allowed for an object's application ID. Originally defined in storlib.h.
            </summary>
            <exclude/>
        </member>
        <member name="F:Soss.Client.CacheFactory._namedCachesByAppId">
            <summary>
            Holds a lookup table of <see cref="T:Soss.Client.NamedCache"/> instances by 
            application id.
            </summary>
        </member>
        <member name="M:Soss.Client.CacheFactory.GetCache">
            <summary>
            Create a cache using the default application id.
            </summary>
            <remarks>
            <para>
            This GetCache overload causes the currently executing application to be a potential recipient of StateServer event notifications for objects in the application's default namespace. To receive notifications, you must also register a handler for the <see cref="E:Soss.Client.NamedCache.ObjectExpired"/> event. Other GetCache overloads allow for finer-grained control over event handling for particular named caches.
            </para><para>
            If code is executing in an AppDomain initialized by ASP.NET, the web app's default cache will based on the name of its AppDomain. This ensures that caches will not be inadvertently shared across web applications. An ASP.NET client can also register with the SOSS Server for its default cache's event notifications, but applications will only receive those notifications if an <see cref="E:Soss.Client.NamedCache.ObjectExpired"/> handler is established.
            </para><para>
            Applications running outside of ASP.NET will use a global default cache.
            </para>
            </remarks>
            <returns>Return instance of <see cref="T:Soss.Client.NamedCache"/>.</returns>
        </member>
        <member name="M:Soss.Client.CacheFactory.GetCache(System.String)">
            <summary>
            Creates a <see cref="T:Soss.Client.NamedCache"/> instance, associating the collection with the provided string identifier.
            </summary>
            <param name="name">Name of the cache.</param>
            <returns>An instance of <see cref="T:Soss.Client.NamedCache"/>.</returns>
            <exception cref="T:System.ArgumentNullException"> Thrown if <paramref name="name"/> is a null reference.</exception>
            <exception cref="T:System.ArgumentException"> Thrown if <paramref name="name"/> has zero length.</exception>
        </member>
        <member name="M:Soss.Client.CacheFactory.GetCache(System.UInt32)">
            <summary>
            Creates a <see cref="T:Soss.Client.NamedCache"/> instance, associating the collection with the provided application ID.
            </summary>
            <param name="appId">Application identifier used internally by the ScaleOut StateServer service.</param>
            <returns>An instance of <see cref="T:Soss.Client.NamedCache"/>.</returns>
            <exception cref="T:System.ArgumentNullException"> Thrown if <paramref name="name"/> is a null reference.</exception>
            <exception cref="T:System.ArgumentException"> Thrown if <paramref name="name"/> has zero length.</exception>
        </member>
        <member name="M:Soss.Client.CacheFactory.GetCache(Soss.Client.StateServerKey)">
            <summary>
            Creates a named cache using the application id extracted from a <see cref="T:Soss.Client.StateServerKey"/> instance.
            </summary>
            <param name="key"><see cref="T:Soss.Client.StateServerKey"/> instance. The application ID in this structure is used to create the named cache.</param>
            <returns>An instance of <see cref="T:Soss.Client.NamedCache"/>.</returns>
            <exception cref="T:System.NotSupportedException">Thrown if the provided <paramref name="key"/> is for an ASP.NET session object being stored in the SOSS server. Session objects cannot be accessed through the <see cref="T:Soss.Client.NamedCache"/> API.</exception>
        </member>
        <member name="M:Soss.Client.CacheFactory.Register(Soss.Client.NamedCache)">
            <summary>
            Register <paramref name="namedCache"/> with the factory.
            </summary>
            <remarks>
            When a <see cref="T:Soss.Client.NamedCache"/> subclass is created using the <see cref="M:Soss.Client.NamedCache.#ctor(System.String)"/> constructor, the constructor registers the cache with
            the cache factory so that the subclass can then be found like any other <see cref="T:Soss.Client.NamedCache"/> instance.
            </remarks>
            <param name="namedCache"></param>
            <exception cref="T:System.InvalidOperationException">
            if a <see cref="T:Soss.Client.NamedCache"/> already exists within the factory for the application
            namespace used by <paramref name="namedCache"/>.
            </exception>
        </member>
        <member name="E:Soss.Client.CacheFactory.NamedCacheCreated">
            <summary>
            An event that fires when a new <see cref="T:Soss.Client.NamedCache"/> is created by the <see cref="T:Soss.Client.CacheFactory"/> before its first use. You may hook this event to initialize
            <see cref="T:Soss.Client.NamedCache"/> settings before the cache's first use.
            </summary>
            <remarks>
            This event fires before the <see cref="T:Soss.Client.NamedCache"/> is visible via the <see cref="T:Soss.Client.CacheFactory"/>. <see cref="M:Soss.Client.CacheFactory.GetCache(System.String)"/> callers will block until any
            handlers registered for this event have executed.
            </remarks>
        </member>
        <member name="T:Soss.Client.NamedCacheCreatedEventHandler">
            <summary>
            The signature required of methods that handle the <see cref="E:Soss.Client.CacheFactory.NamedCacheCreated"/> event.
            </summary>
        </member>
        <member name="T:Soss.Client.NamedCacheCreatedEventArgs">
            <summary>
            Provides the newly-registered cache for the <see cref="E:Soss.Client.CacheFactory.NamedCacheCreated"/> event.
            </summary>
        </member>
        <member name="P:Soss.Client.NamedCacheCreatedEventArgs.NamedCache">
            <summary>
            Returns the newly-registerd <see cref="P:Soss.Client.NamedCacheCreatedEventArgs.NamedCache"/> instance.
            </summary>
        </member>
    </members>
</doc>
