// *********************************************** 
// NAME             : TDPTraceListener.cs      
// AUTHOR           : Amit Patel
// DATE CREATED     : 10 Feb 2011
// DESCRIPTION  	: Class used to listen for logging output
// ************************************************  


using System;
using System.Collections.Generic;
using System.Configuration;
using System.Diagnostics;
using System.Text;
using TDP.Common.PropertyManager;

namespace TDP.Common.EventLogging
{
    #region Event Delegates
    delegate void PublisherDelegate(LogEvent le);

	public delegate void TraceLevelChangeEventHandler(object sender, TraceLevelEventArgs e);
	public delegate void CustomLevelChangeEventHandler(object sender, CustomLevelEventArgs e);
	public delegate void CustomLevelsChangeEventHandler(object sender, CustomLevelsEventArgs e);

	public delegate void DefaultPublisherCalledEventHandler(object sender, DefaultPublisherCalledEventArgs e);

    #endregion

    /// <summary>
	/// Class used to listen for logging output.
	/// An instance of this class should be added to the trace listener set.
	/// </summary>
	/// <example> 
	/// Trace.Listeners.Add(new TDPTraceListener(properties,
	///											customPublishers,
	///											errors));
	/// </example>
    public class TDPTraceListener: TraceListener
    {

        #region Events

        // Need declare events as static since subscribers (all of which are static)
		// may register for events before an instance of TDPTraceListener is created.
		public static event TraceLevelChangeEventHandler OperationalTraceLevelChange;
		public static event CustomLevelChangeEventHandler CustomLevelChange;
		public static event CustomLevelsChangeEventHandler CustomLevelsChange;

        public event DefaultPublisherCalledEventHandler DefaultPublisherCalled;
        #endregion

        #region Private Fields

        private int defaultPublisherIndex;
		
		private LoggingPropertyValidator validator;

		private PublisherDelegate [][] eventPublisherMappings;
		private Dictionary<string,int> eventIndexTable;

        #endregion

        #region Constructors
        /// <summary>
        /// Constructor for TDPTraceListener instances.
        /// </summary>
        /// <param name="properties">Properties used to create listener.</param>
        /// <param name="customPublishers">Array containing zero or more custom event publishers instances. 
        /// Note that this parameter cannot be null, though can be an empty array.</param>
        /// <param name="errors">Holds any errors that occurred during construction.</param>
        /// <exception cref="TDP.Common.TDPException">Unrecoverable error occured when creating the TDPTraceListener instance.</exception>
        public TDPTraceListener(IPropertyProvider properties,
            IEventPublisher[] customPublishers,
            List<string> errors)
            : base("TDPTraceListener")
        {
            this.validator = new LoggingPropertyValidator(properties);

            PublisherGroup standardPublisherGroup = new EventPublisherGroup(properties);
            standardPublisherGroup.CreatePublishers(errors);

            if (customPublishers == null)
                errors.Add(Messages.CustomPublisherArrayBad);

            if (errors.Count == 0)
                ValidateCustomPublishers(properties, customPublishers, errors);

            if (errors.Count == 0)
            {
                ValidateDefaultPublisher(properties, standardPublisherGroup.Publishers.ToArray(), customPublishers, errors);
                ValidateEventProperties(properties, standardPublisherGroup.Publishers.ToArray(), customPublishers, errors);
            }

            if (errors.Count == 0)
                AssignEventsToPublishers(properties, standardPublisherGroup.Publishers.ToArray(), customPublishers);

            if (errors.Count == 0)
            {
                // subscribe to ANY changes that may happen in properties
                properties.Superseded += new SupersededEventHandler(this.OnSuperseded);
            }

            if (errors.Count == 0)
            {
                // Force creation of any static classes that must subscribe to events 
                // generated by TDPTraceListener.
                // This is necessary in case they have not yet been created.
                // (Since static classes are created on first use.)
                TDPTraceSwitch tdpTraceSwitch = new TDPTraceSwitch();
                CustomEventSwitch customEventSwitch = new CustomEventSwitch();

                // Notify subscribers that TDPTraceListener has been created successfully
                if (!NotifySubscribers(properties))
                    errors.Add(Messages.TDPTraceListenerSubscriberNotificationFailed);
            }

            if (errors.Count != 0)
            {
                throw new TDPException(String.Format(Messages.TDPTraceListenerConstructor,
                                                    ConfigurationManager.AppSettings["propertyservice.applicationid"],
                                                    ConfigurationManager.AppSettings["propertyservice.groupid"]),
                                                    false, TDPExceptionIdentifier.ELSTDPTraceListenerConstructor);
            }
        }
        #endregion

        #region Event Handlers
        /// <summary>
		/// Called by properties service to notify changes in property values/
		/// Note that the property changes may or may not be relevent to those used by the Event Logging Service.
		/// </summary>
		/// <param name="sender">Reference to the old (superseded) property provider.</param>
		/// <param name="s">Not currently used.</param>
		private void OnSuperseded(object sender, System.EventArgs s)
		{
			if (TDPTraceSwitch.TraceInfo)
				Trace.Write(new OperationalEvent(TDPEventCategory.Infrastructure,
												 TDPTraceLevel.Info,
												 Messages.TDPTraceListenerPropertyChange));
			
			NotifySubscribers(Properties.Current);
			
			// Re-register handler with the (new) latest properties.
			Properties.Current.Superseded += new SupersededEventHandler(this.OnSuperseded);
		}

        #endregion

        #region Public Methods
        /// <summary>
		/// Publishes a LogEvent object to the appropriate sink as specified in the 
		/// property provider used to create the TDPTraceListener instance.
		/// </summary>
		/// <remarks>
		/// If the event cannot be published by it's configured publisher then an attempt
		/// is made to publish it using the default publisher.
		/// </remarks>
		/// <param name="o"><c>LogEvent</c> to publish.</param>
		/// <exception cref="TDP.Common.TDPException">An error condition prevented the <c>LogEvent</c> from being published by any publisher, including the default publisher.</exception>
		public override void Write(object o)
		{
			int eventArrayIndex = 0;
			LogEvent le = null;

			// Cast object being logged to a LogEvent class instance
			try
			{
				le = (LogEvent)o;
			}
			catch (InvalidCastException invalidCastException)
			{
				throw new TDPException(Messages.TDPTraceListenerUnknownClass, invalidCastException, false, TDPExceptionIdentifier.ELSTDPTraceListenerUnknownObject);
			}
			catch (Exception exception) // catch undocumented exceptions
			{
				throw new TDPException(Messages.TDPTraceListenerUnknownClass, exception, false, TDPExceptionIdentifier.ELSTDPTraceListenerUnknownObject);
			}

			// Check if event type should be logged before proceeding
			if (!le.Filter.ShouldLog(le))
				return;	

			// Determine quick lookup index of event based on it's class name
			eventArrayIndex = eventIndexTable[le.ClassName];


			// Loop through all publishers assigned to event, calling WriteEvent
			for (int publisher = 0; 
				publisher < eventPublisherMappings[eventArrayIndex].GetLength(0);
				publisher++)
			{
				try
				{
					// Call WriteEvent for this publisher
					eventPublisherMappings[eventArrayIndex][publisher](le);

					
					// Audit the fact that the event has been published.
					if (!le.AuditPublishersOff)
					{
						le.PublishedBy = eventPublisherMappings[eventArrayIndex][publisher].Target.GetType().FullName;
					}


				}
				catch (TDPException tdpEx)
				{

					// Log an error, if exception not already logged.
					// Only log for custom events to prevent infinite recursion
					// should the operational event fail to write.
                    if ((le is CustomEvent) && (!tdpEx.Logged))
					{
						OperationalEvent error = 
							new OperationalEvent( TDPEventCategory.Infrastructure,
												  TDPTraceLevel.Error,
                                                  String.Format(Messages.ConfiguredPublisherFailed, le.ClassName, eventPublisherMappings[eventArrayIndex][publisher].Target.GetType().FullName, tdpEx.Message),
                                                  tdpEx);

						Trace.Write(error);
					}

					// Failed to log using configured publisher so 
					// attempt to log event using the default publisher
					try
					{
						if (DefaultPublisherCalled != null)
							DefaultPublisherCalled(this, new DefaultPublisherCalledEventArgs(le));

						eventPublisherMappings[this.defaultPublisherIndex][0](le);
						
						// audit the fact that the event has been published by the default publisher
						if (!le.AuditPublishersOff)
							le.PublishedBy = eventPublisherMappings[this.defaultPublisherIndex][0].Target.GetType().FullName;

						// Log a warning to highlight that default publisher was used.
						// Only report this for custom events to prevent infinite
						// recursion should the operational event fail to write.
						if (le is CustomEvent)
						{
							OperationalEvent warning = 
								new OperationalEvent(TDPEventCategory.Infrastructure,
													 TDPTraceLevel.Warning,
													 String.Format(Messages.TDPTraceListenerDefaultPublisherUsed, le.ClassName));

							Trace.Write(warning);
						}

					}
                    catch (TDPException tdpEx2)
					{
						// All publishers failed to log! This exception will filter up to the trace listener client.
                        throw new TDPException(Messages.TDPTraceListenerDefaultPublisherFailure, tdpEx2, false, TDPExceptionIdentifier.ELSDefaultPublisherFailed);
					}
				}

			}

		}

		/// <summary>
		/// This prototype is not supported by TDPTraceListener.
		/// An OperationalEvent is logged to highlight that it has been called.
		/// </summary>
		public override void Write(string s)
		{
			Write(new OperationalEvent(TDPEventCategory.Infrastructure,
									   TDPTraceLevel.Warning,
									   String.Format(Messages.TDPTraceListenerUnsupportedPrototype, s)));
		}

		/// <summary>
		/// This prototype is not supported by TDPTraceListener.
		/// An OperationalEvent is logged to highlight that it has been called.
		/// </summary>
		public override void Write(object o, string s)
		{
			this.Write(String.Format("{0},{1}", s, o.ToString()));
		}

		/// <summary>
		/// This prototype is not supported by TDPTraceListener.
		/// An OperationalEvent is logged to highlight that it has been called.
		/// </summary>
		public override void Write(string message, string category)
		{
			this.Write(String.Format("{0},{1}", message, category));
		}

		/// <summary>
		/// This prototype is not supported by TDPTraceListener.
		/// An OperationalEvent is logged to highlight that it has been called.
		/// </summary>
		public override void WriteLine(string s)
		{
			this.Write(s);
		}

		/// <summary>
		/// This prototype is not supported by TDPTraceListener.
		/// An OperationalEvent is logged to highlight that it has been called.
		/// </summary>
		public override void WriteLine(object o, string s)
		{
			this.Write(String.Format("{0},{1}", s, o.ToString()));
		}

		/// <summary>
		/// This prototype is not supported by TDPTraceListener.
		/// An OperationalEvent is logged to highlight that it has been called.
		/// </summary>
		public override void WriteLine(object o)
		{
			this.Write(String.Format(o.ToString()));
		}

		/// <summary>
		/// This prototype is not fully supported by TDPTraceListener.
		/// An OperationalEvent is logged to highlight that it has been called.
		/// </summary>
		public override void WriteLine(string message, string category)
		{
			this.Write(String.Format("{0},{1}", message, category));
		}

        #endregion

        #region Private Methods
        /// <summary>
        /// Notifies subscribers that one or more properties have changed.
        /// NB property values are forwarded regardless of whether they have changed
        /// Property values are validated before they are forwarded.
        /// The 'Current' properties are always used.
        /// </summary>
        /// <param name="properties">Latest properties values.</param>
        /// <returns>
        /// Result. True if subscribers were notified without errors, otherwise false if errors occurred. 
        /// </returns>
        private bool NotifySubscribers(IPropertyProvider properties)
        {
            List<string> errors = new List<string>();
            bool result = true;

            if (validator.ValidateProperty(Keys.OperationalTraceLevel, errors))
            {
                string operationalTraceLevel = properties[Keys.OperationalTraceLevel];
                TDPTraceLevel operationalTraceLevelValue
                    = (TDPTraceLevel)PropertyValidator.StringToEnum(typeof(TDPTraceLevel), operationalTraceLevel);

                if (OperationalTraceLevelChange != null)
                    OperationalTraceLevelChange(this, new TraceLevelEventArgs(operationalTraceLevelValue));
            }

            if (validator.ValidateProperty(Keys.CustomEventsLevel, errors))
            {
                string level = properties[Keys.CustomEventsLevel];
                CustomEventLevel levelValue
                    = (CustomEventLevel)PropertyValidator.StringToEnum(typeof(CustomEventLevel), level);

                if (CustomLevelChange != null)
                    CustomLevelChange(this, new CustomLevelEventArgs(levelValue));
            }

            if (validator.ValidateProperty(Keys.CustomEvents, errors))
            {
                Dictionary<string, CustomEventLevel> levels = new Dictionary<string, CustomEventLevel>();

                string[] eventIds = null;
                string events = properties[Keys.CustomEvents];
                if (events.Length != 0) // valid to have no custom events
                    eventIds = events.Split(' ');
                else
                    eventIds = new String[0];

                foreach (string eventId in eventIds)
                {
                    string key = properties[String.Format(Keys.CustomEventName, eventId)];
                    string level = properties[String.Format(Keys.CustomEventLevel, eventId)];

                    levels[key] = (CustomEventLevel)PropertyValidator.StringToEnum(typeof(CustomEventLevel), level);
                }

                if (CustomLevelsChange != null)
                    CustomLevelsChange(this, new CustomLevelsEventArgs(levels));
            }

            if (errors.Count != 0)
            {
                // Write any validation errors to default publisher
                // as operational events.
                // The error text is used as the message
                // of the operational event.
                for (int i = 0; i < errors.Count; i++)
                {
                    // create an operational event representing the error
                    OperationalEvent operationalEvent =
                        new OperationalEvent(TDPEventCategory.Infrastructure,
                        TDPTraceLevel.Error,
                        errors[i].ToString());

                    // write the operational event to the default publisher to ensure that is has a higher chance of being published.
                    eventPublisherMappings[defaultPublisherIndex][0](operationalEvent);
                }

                result = false;
            }

            return result;
        }


        /// <summary>
        /// Maps event to corresponding publishers
        /// </summary>
        /// <param name="properties">Property store provider</param>
        /// <param name="pubishersPropertyKey">Property key identifying publisher</param>
        /// <param name="eventArrayIndexer">Index identifying event in eventPublisherMappings array</param>
        /// <param name="eventHashIndexer">Event index</param>
        /// <param name="standardPublishers">List of standard publishers</param>
        /// <param name="customPublishers">List of custom publishers</param>
        private void AssignEventToPublishers(IPropertyProvider properties,
            string pubishersPropertyKey,
            int eventArrayIndexer,
            string eventHashIndexer,
            IEventPublisher[] standardPublishers,
            IEventPublisher[] customPublishers)
        {

            string[] publisherIds = null;
            string publishers = properties[pubishersPropertyKey];
            publisherIds = publishers.Split(' ');

            int publisherCount = 0;

            PublisherDelegate publisherDelegate = null;

            // allocate a row in the array to store each of the publishers delegates
            eventPublisherMappings[eventArrayIndexer]
                = new PublisherDelegate[publisherIds.GetLength(0)];

            // iterate through publishers to get a delagates
            foreach (string publisher in publisherIds)
            {
                // search for publisher instance in standard publishers
                foreach (IEventPublisher publisherInstance in standardPublishers)
                {
                    if (publisherInstance.Identifier == publisher)
                    {
                        publisherDelegate = new PublisherDelegate(publisherInstance.WriteEvent);
                        break;
                    }
                }

                // if publisher not found in standard publishers then search custom publishers
                if (publisherDelegate == null)
                {
                    foreach (IEventPublisher publisherInstance in customPublishers)
                    {
                        if (publisherInstance.Identifier == publisher)
                        {
                            publisherDelegate = new PublisherDelegate(publisherInstance.WriteEvent);
                            break;
                        }
                    }
                }

                // store delegate in array for this publisher
                eventPublisherMappings[eventArrayIndexer][publisherCount]
                    = publisherDelegate;

                // store array indexer in dictionary table - this is used for fast lookup into array
                eventIndexTable[eventHashIndexer] = eventArrayIndexer;

                publisherCount++;
                publisherDelegate = null;

            }

        }

        /// <summary>
        /// Associates events to publishers
        /// </summary>
        /// <param name="properties">Property data store</param>
        /// <param name="standardPublishers">List of standard publishers</param>
        /// <param name="customPublishers">List of custom publishers</param>
        private void AssignEventsToPublishers(IPropertyProvider properties,
            IEventPublisher[] standardPublishers,
            IEventPublisher[] customPublishers)
        {
            // determine number of event types
            string[] customEventIds = null;
            string customEvents = properties[Keys.CustomEvents];
            if (customEvents.Length != 0) // valid to have no custom events
                customEventIds = customEvents.Split(' ');
            else
                customEventIds = new String[0];

            int numOfEvents = customEventIds.GetLength(0) +
                typeof(TDPTraceLevel).GetFields().GetLength(0) - 2; // values for Undefined and Off are not used for events

            numOfEvents++; // add an extra row to hold the default publisher
            this.defaultPublisherIndex = numOfEvents - 1; // sub 1 since zero based array

            // create array to hold publisher writelog delegates
            eventPublisherMappings = new PublisherDelegate[numOfEvents][];

            // create hash table to store event index lookups
            eventIndexTable = new Dictionary<string,int>();

            // initialise indexer used to for each event row in the array
            int eventArrayIndexer = 0;

            // Set up operational event mappings.
            // Need to use level property to make hash table indexer unique
            AssignEventToPublishers(properties,
                Keys.OperationalEventErrorPublishers,
                eventArrayIndexer,
                OperationalEvent.ClassNamePrefix + TDPTraceLevel.Error.ToString(),
                standardPublishers, customPublishers);

            eventArrayIndexer++;

            AssignEventToPublishers(properties,
                Keys.OperationalEventWarningPublishers,
                eventArrayIndexer,
                OperationalEvent.ClassNamePrefix + TDPTraceLevel.Warning.ToString(),
                standardPublishers, customPublishers);

            eventArrayIndexer++;

            AssignEventToPublishers(properties,
                Keys.OperationalEventVerbosePublishers,
                eventArrayIndexer,
                OperationalEvent.ClassNamePrefix + TDPTraceLevel.Verbose.ToString(),
                standardPublishers, customPublishers);

            eventArrayIndexer++;

            AssignEventToPublishers(properties,
                Keys.OperationalEventInfoPublishers,
                eventArrayIndexer,
                OperationalEvent.ClassNamePrefix + TDPTraceLevel.Info.ToString(),
                standardPublishers, customPublishers);

            eventArrayIndexer++;


            // Set up custom event publisher mappings
            foreach (string customEventId in customEventIds)
            {
                string ceName = properties[String.Format(Keys.CustomEventName, customEventId)];

                AssignEventToPublishers(properties,
                    String.Format(Keys.CustomEventPublishers, customEventId),
                    eventArrayIndexer,
                    ceName,
                    standardPublishers, customPublishers);

                eventArrayIndexer++;
            }

            // set up default publisher
            AssignEventToPublishers(properties,
                Keys.DefaultPublisher,
                this.defaultPublisherIndex,
                "Default", // irrelevent since not used at write time
                standardPublishers, customPublishers);

        }

        /// <summary>
        /// validated custom publishers
        /// </summary>
        /// <param name="properties">Property data store</param>
        /// <param name="publishers">List of custom publishers</param>
        /// <param name="errors">List to hold errors generated during validation</param>
		private void ValidateCustomPublishers(IPropertyProvider properties,
            IEventPublisher[] publishers,
			List<string> errors)
		{
			StringBuilder key = new StringBuilder(50);

			foreach (IEventPublisher publisher in publishers)
			{
			
				if ((publisher.Identifier.Length == 0) ||
					(publisher.Identifier == null))
				{
					errors.Add(String.Format(Messages.CustomPublisherInvalidId, 
						publisher.GetType().Name,
						publisher.Identifier));
				}
				else
				{			
					key.Length = 0;
					key.Append(String.Format(Keys.CustomPublisherName, publisher.Identifier));

					if (properties[key.ToString()] != publisher.GetType().Name)
					{
						errors.Add(String.Format(Messages.CustomPublisherNameMismatch, 
							publisher.GetType().Name,
							key.ToString() ));
					
					}

				}
				

			}
			
		}

        /// <summary>
        /// Overladed method  - Validates if the publishers defined by eventKey valid and exists 
        /// </summary>
        /// <param name="publisherId">Publisher id</param>
        /// <param name="key">Property identifier key</param>
        /// <param name="standardPublishers">List of standard publishers</param>
        /// <param name="customPublishers">List of custom publishers</param>
        /// <param name="errors">List to hold errors generated during validation</param>
        /// <returns>Returns true if the publisher exists, false otherwise</returns>
		private bool ValidatePublisherExists(string publisherId,
			string key,
            IEventPublisher[] standardPublishers,
            IEventPublisher[] customPublishers,
            List<string> errors)
		{
			bool found = false;

			foreach (IEventPublisher publisher in standardPublishers)
			{
				if (publisher.Identifier == publisherId)
				{
					found = true;
					break;
				}
			}

			if (!found)
			{
				foreach (IEventPublisher publisher in customPublishers)
				{
					if (publisher.Identifier == publisherId)
					{
						found = true;
						break;
					}
				}
			}

			if (!found)
			{
				errors.Add(String.Format(Messages.UndefinedPublisher, key, publisherId));
			}

			return found;
		}

        /// <summary>
        /// Overladed method  - Validates if the publishers defined by eventKey valid and exists 
        /// </summary>
        /// <param name="properties">Property data store</param>
        /// <param name="eventKey">Key defining property to hold publisher ids</param>
        /// <param name="standardPublishers">List of standard publishers</param>
        /// <param name="customPublishers">List of custom publishers</param>
        /// <param name="errors">List to hold errors generated during validation</param>
		private void ValidatePublishersExist(IPropertyProvider properties, 
											 string eventKey,
                                             IEventPublisher[] standardPublishers,
                                             IEventPublisher[] customPublishers,
                                             List<string> errors)
		{
			
			string[] Ids = null;
			string publisherIds = properties[eventKey];

			if (publisherIds != null)
			{
				if (publisherIds.Length != 0)
					Ids = publisherIds.Split(' ');
				else
				{
					errors.Add(String.Format(Messages.EventHasZeroPublishers, eventKey));
					Ids = new String[0];
				}
			}
			else
			{
				errors.Add(String.Format(Messages.EventHasZeroPublishers, eventKey));
				Ids = new String[0];
			}

			foreach (string id in Ids)
			{
				ValidatePublisherExists(id, eventKey, standardPublishers, customPublishers, errors);	
			}
		}

        /// <summary>
        /// Validates publisher properties defined in property data store
        /// </summary>
        /// <param name="properties">Property data store</param>
        /// <param name="standardPublishers">List of standard publishers</param>
        /// <param name="customPublishers">List of custom publishers</param>
        /// <param name="errors">List to hold errors generated during validation</param>
		private void ValidateEventProperties(IPropertyProvider properties,
            IEventPublisher[] standardPublishers,
            IEventPublisher[] customPublishers,
            List<string> errors)
		{
			// validate trace levels
			validator.ValidateProperty(Keys.OperationalTraceLevel, errors);
			validator.ValidateProperty(Keys.CustomEventsLevel, errors);
			
			// validate publisher property for all custom events
			string[] customEventIds = null;
			string customEvents = properties[Keys.CustomEvents];
			if (customEvents != null)
			{
				if (customEvents.Length != 0) // valid to have no custom events
					customEventIds = customEvents.Split(' ');
				else
					customEventIds = new String[0];
			}
			else
			{
				// NB validation of missing custom events key is performed elsewhere
				customEventIds = new String[0];
			}

			foreach (string customEventId in customEventIds)
			{	
				ValidatePublishersExist(properties,
										String.Format(Keys.CustomEventPublishers, customEventId),
										standardPublishers, 
										customPublishers, errors);
			}

			// validate publishers for operational events
			ValidatePublishersExist(properties,
									Keys.OperationalEventVerbosePublishers,
									standardPublishers, customPublishers, errors);

			ValidatePublishersExist(properties,
								    Keys.OperationalEventInfoPublishers,
									standardPublishers, customPublishers, errors);

			ValidatePublishersExist(properties,
									Keys.OperationalEventErrorPublishers,
									standardPublishers, customPublishers, errors);

			ValidatePublishersExist(properties,
									Keys.OperationalEventWarningPublishers,
									standardPublishers, customPublishers, errors);

			
			// validate "non-publisher properties" for all custom events
			validator.ValidateProperty(Keys.CustomEvents, errors);

		}

        /// <summary>
        /// Vadiates if default publisher exists
        /// </summary>
        /// <param name="properties">Proeprty store provider object</param>
        /// <param name="standardPublishers">List of standart publisher objects i.e. QueuePublisher etc.</param>
        /// <param name="customPublishers">List of custom publisher objects</param>
        /// <param name="errors">List of string errors</param>
		private void ValidateDefaultPublisher(IPropertyProvider properties,
            IEventPublisher[] standardPublishers,
            IEventPublisher[] customPublishers,
            List<string> errors)
		{
			if (validator.ValidateProperty(Keys.DefaultPublisher, errors))
				ValidatePublisherExists(properties[Keys.DefaultPublisher],
										Keys.DefaultPublisher,
										standardPublishers, customPublishers, errors);


        }

        #endregion

    }
}
